
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>jintao&#8217;s blog</title>
  <meta name="author" content="jintao">

  
  <meta name="description" content="Golang语言提供了正常的流程控制：if、for、switch和goto。还提供了go表达式创建goroutine协程。接下来将要介绍的是：defer、panic和recovery defer defer表达式将一个函数放到一个list中。包裹defer函数的函数return时， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jintao-zero.github.io/posts/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="jintao's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" -->

<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">jintao&#8217;s blog</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jintao-zero.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/03/07/golang-defer-panic-he-recoverjie-shao/">Golang Defer Panic 和Recover介绍和实践</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-07T11:08:41+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>11:08 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Golang语言提供了正常的流程控制：if、for、switch和goto。还提供了go表达式创建goroutine协程。接下来将要介绍的是：<code>defer</code>、<code>panic</code>和<code>recovery</code></p>

<h2>defer</h2>

<p>defer表达式将一个函数放到一个list中。包裹defer函数的函数return时，这个defer函数将会被执行。<code>Defer</code>通常被用来简化资源清理动作。  <br/>
下面的代码片段，完成的功能是打开两个文件，将一个文件的内容拷贝到另外一个文件中：</p>

<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }

    written, err = io.Copy(dst, src)
    dst.Close()
    src.Close()
    return
}
</code></pre>

<p>这个片段有bug。当调用os.Createa失败时，函数返回，但是没有将已经打开的源文件关闭。在第二个return语句之前执行src.Close可以修复bug。但是如果存在多个资源需要关闭或者多个return语句时，这样就比较繁琐。使用defer表达式，可以方便确保资源关闭：</p>

<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }
    defer src.Close()

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }
    defer dst.Close()

    return io.Copy(dst, src)
}
</code></pre>

<p>Defer表达式会提醒我们在打开文件之后关闭资源，并且确保无论多少return语句都会将资源关闭。<br/>
defer表达式的行为是简单和可预测的。下面有三条简单规则：</p>

<ol>
<li><p>注册defer函数时，计算deferred函数的参数
下面的例子中，defer表达式注册fmt.Println函数时确定了入参为0，下面函数执行return语句时，fmt.Println将会打印出0</p>

<pre><code>  func a() {
      i := 0
      defer fmt.Println(i)
      i++
      return
  }
</code></pre></li>
<li><p>注册函数按照先进后出的的顺序进行执行</p>

<pre><code> func b() {
     for i := 0; i &lt; 4; i++ {
         defer fmt.Print(i)
      }
 }
</code></pre>

<p> 打印结果是“3210”</p></li>
<li><p>Deferred函数可以读写包裹函数的命名返回值
下面的例子中，包裹函数返回后，deferred函数修改了命名返回值i。因此，包裹函数的返回值为2</p>

<pre><code>  func c() (i int) {
      defer func() { i++ }()
      return 1
  }
</code></pre>

<p>  这个特点可以用来修改函数返回的error返回值</p></li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2017/03/07/golang-defer-panic-he-recoverjie-shao/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/03/06/golang-reflectjie-shao/">Golang Reflect介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-06T17:44:02+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>5:44 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Golang <a href="https://golang.org/pkg/reflect/">reflect</a>包实现了运行时反射，允许程序管理任意类型对象。典型应用是使用<code>TypeOf</code>从静态类型<code>interface{}</code>中抽取动态类型信息。<br/>
使用<code>ValueOf</code>返回一个<code>Value</code>类型变量代表运行时数据。<br/>
<a href="https://golang.org/doc/articles/laws_of_reflection.html">The Laws of Reflection</a>介绍了Golang reflect机智中的几条规则：</p>

<h2>从interface反射到对象</h2>

<p>反射基本功能是用来检查interface变量中保存的<code>类型</code>和<code>数据</code>对。<a href="http://golang.org/pkg/reflect/">package reflect</a>中提供了两种类型：<a href="http://golang.org/pkg/reflect/#Type">Type</a>和<a href="http://golang.org/pkg/reflect/#Value">Value</a>。这两种类型提供了反问interface内部数据的机制。调用<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>函数分别返回<code>reflect.Type</code>和<code>reflect.Value</code>变量：</p>

<pre><code>ackage main

import (
"fmt"
"reflect"
)

func main() {
    var x float64 = 3.4
    fmt.Println("type:", reflect.TypeOf(x))
}
</code></pre>

<p>程序输出如下：</p>

<pre><code>type: float64
</code></pre>

<p><code>reflect.TypeOf</code>函数定义如下：</p>

<pre><code>// TypeOf returns the reflection Type of the value in the interface{}.
func TypeOf(i interface{}) Type
</code></pre>

<p>当我们调用<code>TypeOf(x)</code>时，x首先存在一个空interface中，之后作为参数，reflect.TypeOf解析参数获取实际类型。  <br/>
调用<code>Value(x)</code>时，从接口参数中获取实参值。</p>

<pre><code>var x float64 = 3.4
fmt.Println("value:", reflect.ValueOf(x))
</code></pre>

<p>打印结果如下：</p>

<pre><code>value: &lt;float64 Value&gt;
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2017/03/06/golang-reflectjie-shao/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/02/03/golangshi-yong-protobufda-jian-rpc/">Golang使用protobuf搭建rpc</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-02-03T19:55:10+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2017</span></span> <span class='time'>7:55 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/18/gobing-fa-mo-xing-zhi-context/">Go并发模型之Context</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-01-18T15:26:37+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>3:26 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Go语言中go和channel是开发高并发程序的基础。我们使用channel进行goroutine程序通讯，传送数据和控制信号，<a href="https://blog.golang.org/pipelines">Pipelines and Cancelation</a>向我们讲解了如何利用Done通道来向goroutine发送结束信号：</p>

<pre><code>func main() {
    var done = make(chan struct {})
    go func(done chan struct{}) {
        select {
        case &lt;- done:
            fmt.Println("receive exit signal")
        }
    }(done)

    done &lt;- struct {}{}
    time.Sleep(3 * time.Second)
}
</code></pre>

<p>在Go服务端，每一个请求都对应会有一个goroutine进行处理。处理函数通常又会开启另外的goroutine去访问后段服务，比如数据库和RPC服务。对应一个请求创建的这一系列的goroutine通常会需要访问请求相关的信息，比如终端用户名，授权token和请求的deadline等等。当一个请求被取消或者处理超时，与这个请求相关的一些列goroutine应该尽快退出，以便系统回收资源。<br/>
Go中<code>context</code>包提供了这样的功能，利用context包可以进行请求范围内的数据传递，发送请求信号和deadline查看。本文简单示例如何使用<code>context</code>包进行goroutine并发编程。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2017/01/18/gobing-fa-mo-xing-zhi-context/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/13/golang-goming-ling-xiang-jie/">Golang Go命令详解</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-01-13T19:17:12+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>7:17 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>go命令</h1>

<p><a href="#compile">Compile packages and dependencies</a>    <br/>
<a href="#clean">Remove object files</a><br/>
<a href="#testing">Description of testing flags</a></p>

<p><code>Go</code>工具用来管理Go语音源代码。
使用：</p>

<pre><code>go command [arguments]
</code></pre>

<p>命令为：</p>

<pre><code>build       compile packages and dependencies
clean       remove object files
doc         show documentation for package or symbol
env         print Go environment information
fix         run go tool fix on packages
fmt         run gofmt on package sources
generate    generate Go files by processing source
get         download and install packages and dependencies
install     compile and install packages and dependencies
list        list packages
run         compile and run Go program
test        test packages
tool        run specified go tool
version     print Go version
vet         run go tool vet on packages
</code></pre>

<p>使用<code>go help [command]</code>查看命令相信信息。<br/>
更多topic：</p>

<pre><code>c           calling between Go and C
buildmode   description of build modes
filetype    file types
gopath      GOPATH environment variable
environment environment variables
importpath  import path syntax
packages    description of package lists
testflag    description of testing flags
testfunc    description of testing functions
</code></pre>

<p>使用<code>go help [topic]</code>查看topic帮助信息</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2017/01/13/golang-goming-ling-xiang-jie/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/08/golang-tong-guo-httpfu-wu-huo-qu-cheng-xu-xing-neng-tong-ji-shu-ju/">Golang 通过http服务获取程序性能统计数据</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-01-08T22:55:07+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>10:55 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Golang标准库<code>net/http/pprof</code>通过HTTP服务对外提供性能统计数据，以便<code>pprof</code>这样的可视化工具使用。</p>

<p>引入此<code>pprof</code>库向http服务注册路径处理函数。此库注册的http服务路径都是以<code>/debug/pprof</code>开头。</p>

<h2>使用方法</h2>

<h3>方式引入库</h3>

<pre><code>import _ "net/http/pprof"
</code></pre>

<h3>开启HTTP服务</h3>

<p>如果程序中已经运行了一个或者多个HTTP服务，那么就无需再开启HTTP服务，否则需要像如下代码片段，开启一个HTTP服务：</p>

<pre><code>go func() {
    log.Println(http.ListenAndServe("localhost:6060",   nil))
}()
</code></pre>

<p>其中地址也可以不绑定到localhost,可以选择监听所有端口,比如:</p>

<pre><code>go func() {
    log.Println(http.ListenAndServe(":6060",    nil))
}()
</code></pre>

<h3>获取性能数据</h3>

<p>1、查看堆栈性能数据</p>

<pre><code>go tool pprof http://localhost:6060/debug/pprof/heap
</code></pre>

<p>2、查看30s CPU性能数据</p>

<pre><code>go tool pprof http://localhost:6060/debug/pprof/profile
</code></pre>

<p>3、查看goroutine阻塞性能数据</p>

<pre><code>go tool pprof http://localhost:6060/debug/pprof/block
</code></pre>

<p>4、查看5s执行栈</p>

<pre><code>wget http://localhost:6060/debug/pprof/trace?seconds=5
</code></pre>

<p>5、查看所有可用性能数据</p>

<pre><code>浏览器打开  http://localhost:6060/debug/pprof/
</code></pre>

<p>参考：<br/>
<a href="https://golang.org/pkg/net/http/pprof/">Golang官博</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/05/golangchuang-jian-,-jie-ya-dot-tar-dot-gzwen-jian/">golang创建、解压.tar.gz文件简单库</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-01-05T19:17:06+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>7:17 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>golang提供了<code>tar</code>包和<code>compress/gzip</code>包进行文件打包和压缩，但是没有函数同时进行打包和压缩，下面利用打包和压缩功能，实现一个简单的制作和解压.tar.gz文件的功能。</p>

<h2>tar打包功能</h2>

<p>利用tar中<code>Writer</code>和<code>Reader</code>可以实现将文件和文件夹进行打包的功能。</p>

<h3>打包</h3>

<p>创建目标文件</p>

<pre><code>f, err := os.Create(dstPath)
</code></pre>

<p>创建<code>Writer</code></p>

<pre><code>tw := tar.NewWriter(f)
</code></pre>

<p>循环遍历文件夹，写入Writer</p>

<pre><code>fileInfo, err := os.Stat(path)
if err != nil {
    return err
}
if fileInfo.Mode().IsRegular() {
    header, err := tar.FileInfoHeader(fileInfo, "")
    if err != nil {
        return err
    }
    header.Name = path
    if err = tw.WriteHeader(header); err != nil {
        return err
    }
    file, err := os.Open(path)
    if err != nil {
        return err
    }
    if _, err = io.Copy(tw, file); err != nil {
        return err
    }
}

if fileInfo.Mode().IsDir() {
    // tar each file and dir in the dir
    var file *os.File
    if file, err = os.Open(path); err != nil {
        return err
    }
    fileInfos, err := file.Readdir(0)
    if err != nil {
        return err
    }
    for _, info := range fileInfos {
        if err = tarPath(filepath.Join(path, info.Name()), tw); err != nil {
            return err
        }
    }
}
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2017/01/05/golangchuang-jian-,-jie-ya-dot-tar-dot-gzwen-jian/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/01/01/golang-cpuxing-neng-you-hua/">Golang Cpu性能优化</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-01-01T17:18:20+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2017</span></span> <span class='time'>5:18 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文根据<a href="https://blog.golang.org/profiling-go-programs">Profiling Go Programs</a>文章，进行演示如何利用Golang性能工具进行cpu性能统计和优化。</p>

<h2>准备工作</h2>

<p>1、Golang编译运行环境。</p>

<pre><code>go version go1.7 darwin/amd64
</code></pre>

<p>2、下载<a href="https://storage.googleapis.com/google-code-archive-source/v2/code.google.com/benchgraffiti/source-archive.zip">测试源码</a></p>

<pre><code>-rw-r--r-- 1 jintao staff 16594  1  1 16:58 havlak1.go
-rw-r--r-- 1 jintao staff 16597  1  1 16:58 havlak2.go
-rw-r--r-- 1 jintao staff 16832  1  1 16:58 havlak3.go
-rw-r--r-- 1 jintao staff 16905  1  1 16:58 havlak4.go
-rw-r--r-- 1 jintao staff 17501  1  1 16:58 havlak5.go
-rw-r--r-- 1 jintao staff  9467  1  1 16:58 havlak6.go
</code></pre>

<p>havlak1-6是源文件，以及优化后的源文件</p>

<h2>采集CPU性能数据</h2>

<p>优化程序之前，需要采集性能数据。多种方法可以使用，本文中采用的方法是引入<code>runtime/pprof</code>包，在代码文件main函数中添加如下代码片段:</p>

<pre><code>var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

func main() {
    flag.Parse()
    if *cpuprofile != "" {
        f, err := os.Create(*cpuprofile)
        if err != nil {
          log.Fatal(err)
        }
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
    ... 
</code></pre>

<p>利用flag包设置并解析cpuprofile参数，传入文件名，创建文件，调用<code>ppfof.StartCPUProfile</code>方法开始进行采样，并将采样结果保存在文件中，在程序返回之前调用<code>pprof.StopCPUProfile</code>方法确保所有采样数据刷新到结果文件中。</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ time ./havlak1 -cpuprofile=havlak1.prof
# of loops: 76000 (including 1 artificial root node)

real    0m21.768s
user    0m31.026s
sys 0m0.284s
</code></pre>

<p>产生性能文件havlak1.prof</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2017/01/01/golang-cpuxing-neng-you-hua/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/30/golangri-qi-zhuan-hua-chu-li/">Golang日期转化处理</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-30T22:13:12+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>golang中time包提供了时间操作函数。</p>

<h2>获取时间</h2>

<pre><code>type Time struct {
    // contains filtered or unexported fields
}

func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time
func Now() Time
</code></pre>

<p>一个Time结构体代表一个纳米精度的时间实例。now函数可以获取当前时间：</p>

<pre><code>now := time.Now()
fmt.Println(now)
</code></pre>

<p>结果如下：</p>

<pre><code>2016-11-27 22:46:17.666418725 +0800 CST 
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/10/30/golangri-qi-zhuan-hua-chu-li/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/05/grepming-ling/">Grep命令</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-05T20:48:14+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:48 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>grep命令</h1>

<p>grep, egrep, fgrep, zgrep, zegrep, zfgrep 文件模式搜索</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num] [-B num] [-C[num]] [-e pattern] [-f file] [--binary-files=value] [--color[=when]]
</span><span class='line'>          [--colour[=when]] [--context[=num]] [--label] [--line-buffered] [--null] [pattern] [file ...]</span></code></pre></td></tr></table></div></figure>


<p>grep搜索输入文件，输出匹配一个或者多个模式的文件行。通常情况，不包括结尾换行符的文件行匹配指定模式中的表达式即为匹配成功。空表达式匹配所有行。匹配行将会打印到标准输出。<br/>
grep命令用于简单模式和基本正则表达式（BRES）；egrep命令可以处理扩展正则表达式。查看re_format(7）关于正则表达式的详细信息。fgre较grep和egrep更快，但是只能处理固定模式（比如，它不能解析正则表达式）。匹配模式可以由一行或者多行组成，以便于匹配输入内容的一部分。<br/>
zgrep，zegrep，zfgrep分别与grep，egrep，fgrep功能类似，只是可以接收由compress或者gzip压缩工具压缩过的文件作为输入。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/10/05/grepming-ling/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/08/09/opensslshi-zhan/">Openssl实战</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/08/09/zookeepershi-zhan/">Zookeeper实战</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/06/20/golangjia-liang-bian-du-suo-dao-zhi-cheng-xu-si-suo-wen-ti-ji-lu/">Golang加两遍读锁导致程序死锁问题分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/06/14/godai-ma-zou-du-gui-fan/">Go代码走读规范</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/06/11/golang-gong-cheng-dai-ma-jie-gou/">Golang 工程代码结构</a>
      </li>
    
  </ul>
</section>
<section>
 <h1>Categories</h1>
 <ul id="categories">
	 <li class='category'><a href='/blog/categories/alogrithm/'>alogrithm (1)</a></li>
<li class='category'><a href='/blog/categories/bigdata/'>bigdata (3)</a></li>
<li class='category'><a href='/blog/categories/dev/'>dev (2)</a></li>
<li class='category'><a href='/blog/categories/devops/'>devops (3)</a></li>
<li class='category'><a href='/blog/categories/go/'>go (1)</a></li>
<li class='category'><a href='/blog/categories/network/'>network (9)</a></li>
<li class='category'><a href='/blog/categories/nosql/'>nosql (1)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (2)</a></li>
<li class='category'><a href='/blog/categories/ops/'>ops (2)</a></li>
<li class='category'><a href='/blog/categories/program/'>program (12)</a></li>
<li class='category'><a href='/blog/categories/tool/'>tool (1)</a></li>
<li class='category'><a href='/blog/categories/unix/'>unix (2)</a></li>

 </ul>
</section>
<section>
<h1>Tags</h1>
<ul class="tag-cloud">
	<a style="font-size: 90%" href="/blog/tags/alogrithm/">Alogrithm</a>
<a style="font-size: 126%" href="/blog/tags/devops/">DevOps</a>
<a style="font-size: 210%" href="/blog/tags/golang/">Golang</a>
<a style="font-size: 90%" href="/blog/tags/http/">HTTP</a>
<a style="font-size: 126%" href="/blog/tags/hadoop/">Hadoop</a>
<a style="font-size: 90%" href="/blog/tags/hdfs/">Hdfs</a>
<a style="font-size: 90%" href="/blog/tags/linux/">Linux</a>
<a style="font-size: 90%" href="/blog/tags/markdown/">Markdown</a>
<a style="font-size: 191%" href="/blog/tags/network/">Network</a>
<a style="font-size: 90%" href="/blog/tags/nosql/">Nosql</a>
<a style="font-size: 126%" href="/blog/tags/python/">Python</a>
<a style="font-size: 90%" href="/blog/tags/redis/">Redis</a>
<a style="font-size: 90%" href="/blog/tags/socks/">SOCKS</a>
<a style="font-size: 126%" href="/blog/tags/unix/">Unix</a>
<a style="font-size: 90%" href="/blog/tags/go/">go</a>
<a style="font-size: 126%" href="/blog/tags/golang/">golang</a>
<a style="font-size: 90%" href="/blog/tags/mapreduce/">mapreduce</a>
<a style="font-size: 90%" href="/blog/tags/openssl/">openssl</a>
<a style="font-size: 90%" href="/blog/tags/protocol-buffer/">protocol-buffer</a>
<a style="font-size: 90%" href="/blog/tags/ssh/">ssh</a>
<a style="font-size: 90%" href="/blog/tags/tls/">tls</a>
<a style="font-size: 90%" href="/blog/tags/zookeeper/">zookeeper</a>

</ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - jintao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
