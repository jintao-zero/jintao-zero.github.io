<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ops | jintao's blog]]></title>
  <link href="http://jintao-zero.github.io/blog/categories/ops/atom.xml" rel="self"/>
  <link href="http://jintao-zero.github.io/"/>
  <updated>2017-09-04T20:23:38+08:00</updated>
  <id>http://jintao-zero.github.io/</id>
  <author>
    <name><![CDATA[jintao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用strace调试进程]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/09/04/shi-yong-stracediao-shi-jin-cheng/"/>
    <updated>2017-09-04T18:44:00+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/09/04/shi-yong-stracediao-shi-jin-cheng</id>
    <content type="html"><![CDATA[<p><code>Strace</code>调试工具可以帮助定位问题。  <br/>
<code>Strace</code>工具可以用来记录指定程序运行过程中涉及的系统调用和信号。在没有获取程序源代码的情况下，strace工具可以有效帮助对程序的调试。strace工具提供一个二进制程序从开始到结束的执行顺序。  <br/>
下面几个例子展示如何使用<code>strace</code>工具：</p>

<!-- more -->


<ol>
<li><p>跟踪可执行程序的执行<br/>
可以使用strace工具跟踪任何可执行程序的执行。下面例子是使用strace跟踪linux ls命令的执行过程：</p>

<pre><code class="``">$  strace ls
execve("/bin/ls", ["ls"], [/* 21 vars */]) = 0
brk(0)                                  = 0x8c31000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb78c7000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=65354, ...}) = 0
...
...
...
</code></pre></li>
<li><p>使用-e参数跟踪特定系统调用<br/>
strace默认跟踪执行程序的所有系统调用。可以使用<code>-e</code>参数跟踪特定系统调用：</p>

<pre><code class="``">$ strace -e open ls
open("/etc/ld.so.cache", O_RDONLY)      = 3
open("/lib/libselinux.so.1", O_RDONLY)  = 3
open("/lib/librt.so.1", O_RDONLY)       = 3
open("/lib/libacl.so.1", O_RDONLY)      = 3
open("/lib/libc.so.6", O_RDONLY)        = 3
open("/lib/libdl.so.2", O_RDONLY)       = 3
open("/lib/libpthread.so.0", O_RDONLY)  = 3
open("/lib/libattr.so.1", O_RDONLY)     = 3
open("/proc/filesystems", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = 3
open(".", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
Desktop  Documents  Downloads  examples.desktop  libflashplayer.so 
Music  Pictures  Public  Templates  Ubuntu_OS  Videos
</code></pre>

<p>如果想执行多个系统调用，可以使用<code>-e trace=</code>选项。下面例子跟踪open和read系统调用：</p>

<pre><code class="``">  $ strace -e trace=open,read ls /home
open("/etc/ld.so.cache", O_RDONLY)      = 3
open("/lib/libselinux.so.1", O_RDONLY)  = 3
read(3, "\177ELF\1\1\1\3\3\1\260G004"..., 512) = 512
open("/lib/librt.so.1", O_RDONLY)       = 3
read(3, "\177ELF\1\1\1\3\3\1\300\30004"..., 512) = 512
..
open("/lib/libattr.so.1", O_RDONLY)     = 3
read(3, "\177ELF\1\1\1\3\3\1\360\r004"..., 512) = 512
open("/proc/filesystems", O_RDONLY|O_LARGEFILE) = 3
read(3, "nodev\tsysfs\nnodev\trootfs\nnodev\tb"..., 1024) = 315
read(3, "", 1024)                       = 0
open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = 3
open("/home", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
bala
</code></pre></li>
<li><p>保存调用过程到文件<br/>
下面例子使用<code>-o</code>参数保存调用过程到文件中：</p>

<pre><code class="``">  $ strace -o output.txt ls
  Desktop  Documents  Downloads  examples.desktop  libflashplayer.so
Music  output.txt  Pictures  Public  Templates  Ubuntu_OS  Videos

  $ cat output.txt 
execve("/bin/ls", ["ls"], [/* 37 vars */]) = 0
brk(0)                                  = 0x8637000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7860000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=67188, ...}) = 0
...
...
</code></pre></li>
<li><p>使用<code>-p</code>参数跟踪正在运行的进程<br/>
 先使用ps命令获取正在运行进程的id<br/>
 <code>
 $ ps -C firefox-bin
   PID TTY          TIME CMD
 1725 ?        00:40:50 firefox-bin
</code>
 使用<code>-p</code>指定strace需要跟踪进程的id</p>

<pre><code class="`"> $ sudo strace -p 1725 -o firefox_trace.txt

 $ tail -f firefox_trace.txt
</code></pre>

<p> 进程系统调用将会被写入到文件中，使用tail命令可以查看最近执行序列。</p></li>
<li><p>使用<code>-t</code>参数为每行输出显示时间戳</p>

<pre><code class="`"> $ strace -t -e open ls /home
20:42:37 open("/etc/ld.so.cache", O_RDONLY) = 3
20:42:37 open("/lib/libselinux.so.1", O_RDONLY) = 3
20:42:37 open("/lib/librt.so.1", O_RDONLY) = 3
20:42:37 open("/lib/libacl.so.1", O_RDONLY) = 3
20:42:37 open("/lib/libc.so.6", O_RDONLY) = 3
20:42:37 open("/lib/libdl.so.2", O_RDONLY) = 3
20:42:37 open("/lib/libpthread.so.0", O_RDONLY) = 3
20:42:37 open("/lib/libattr.so.1", O_RDONLY) = 3
20:42:37 open("/proc/filesystems", O_RDONLY|O_LARGEFILE) = 3
20:42:37 open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = 3
20:42:37 open("/home", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
bala
</code></pre></li>
<li><p>使用<code>-r</code>参数输出每个系统调用执行时间</p>

<pre><code class="`"> $ strace -r ls 
  0.000000 execve("/bin/ls", ["ls"], [/* 37 vars */]) = 0
  0.000846 brk(0)                    = 0x8418000
  0.000143 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
  0.000163 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb787b000
  0.000119 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
  0.000123 open("/etc/ld.so.cache", O_RDONLY) = 3
  0.000099 fstat64(3, {st_mode=S_IFREG|0644, st_size=67188, ...}) = 0
  0.000155 mmap2(NULL, 67188, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb786a000
  ...
  ...
</code></pre></li>
<li><p>使用<code>-c</code>参数显示系统调用统计报告<br/>
 使用<code>-c</code>参数可以输出程序执行期间系统调用的统计数据：包括执行时间占比，执行时间，执行次数，错误数:</p>

<pre><code> $ strace -c ls /home
 bala
 % time     seconds  usecs/call     calls    errors syscall
 ------ ----------- ----------- --------- --------- ----------------
 -nan    0.000000           0         9           read
 -nan    0.000000           0         1           write
 -nan    0.000000           0        11           open


 -nan    0.000000           0        13           close
 -nan    0.000000           0         1           execve
 -nan    0.000000           0         9         9 access
 -nan    0.000000           0         3           brk
 -nan    0.000000           0         2           ioctl
 -nan    0.000000           0         3           munmap
 -nan    0.000000           0         1           uname
 -nan    0.000000           0        11           mprotect
 -nan    0.000000           0         2           rt_sigaction
 -nan    0.000000           0         1           rt_sigprocmask
 -nan    0.000000           0         1           getrlimit
 -nan    0.000000           0        25           mmap2
 -nan    0.000000           0         1           stat64
 -nan    0.000000           0        11           fstat64
 -nan    0.000000           0         2           getdents64
 -nan    0.000000           0         1           fcntl64
 -nan    0.000000           0         2         1 futex
 -nan    0.000000           0         1         set_thread_area
 -nan    0.000000           0         1           set_tid_address
 -nan    0.000000           0         1           statfs64
 -nan    0.000000           0         1              set_robust_list
 ------ ----------- ----------- --------- --------- ----------------
 100.00    0.000000                   114        10 total
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openssl实战]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/08/09/opensslshi-zhan/"/>
    <updated>2017-08-09T17:50:42+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/08/09/opensslshi-zhan</id>
    <content type="html"><![CDATA[<p>本篇文章主要是对openssl的使用进行实践总结。</p>

<ul>
<li><a href="#key">生成密钥</a></li>
<li><a href="#crt">创建证书</a></li>
<li><a href="#practice">实践</a></li>
</ul>


<!-- more -->


<h2><span id="key">生成密钥</span></h2>

<h3>生成RSA密钥</h3>

<p>命令：<br/>
<code>
openssl genrsa [-out filename] [-passout arg] [-aes128] [-aes128] [-aes192] [-aes256] [-camellia128] [-camellia192] [-camellia256] [-aes192]
       [-aes256] [-camellia128] [-camellia192] [-camellia256] [-des] [-des3] [-idea] [-f4] [-3] [-rand file(s)] [-engine id] [numbits]
</code>
参数：<br/>
<code>-out filename</code> 输出到结果文件。如果不指定，则输出到标准输出。<br/>
<code>-aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea</code> <br/>
指定加密算法加密密钥。<br/>
<code>numbits</code>指定密钥位数。默认为512位</p>

<p>生成一个2048位rsa非对称密钥，保存到rsa-fd.key文件中：</p>

<pre><code>openssl genrsa -out rsa-fd.key 2048
</code></pre>

<p><code>rsa-fd.key</code>文件为<code>PEM</code>格式：</p>

<pre><code>$ file rsa-fd.key
rsa-fd.key: PEM RSA private key
</code></pre>

<p>使用<code>rsa</code>命令解析出私钥结构：</p>

<pre><code>openssl rsa -text -in rsa-fd.key
</code></pre>

<p>查看私钥中的公开部分：</p>

<pre><code>openssl rsa -in rsa-fd.key -pubout -out rsa-pub.key
</code></pre>

<h3>生成DSA密钥</h3>

<p>DSA的密钥生成分成两个部分:先生成DSA的参数，然后再生成密钥。
命令：</p>

<pre><code>openssl dsaparam -genkey 2048 | openssl dsa -out dsa.key
</code></pre>

<h3>生成ECDSA密钥</h3>

<p>创建ECDSA密钥的过程是类似的，但是不能创建任意长度的密钥。对于每个密钥，你需要选择一个命名曲线(named curve)，它可以控制密钥长度，同时也限定了椭圆曲线的参数。下面的例子使用secp256r1这个命名曲线创建一个256位长度的ECDSA密钥</p>

<pre><code>openssl ecparam -genkey -name secp256r1 | openssl ec -out ec.key
</code></pre>

<h2><span id="crt">创建证书</span></h2>

<h3>创建证书申请</h3>

<blockquote><p>使用openssl req命令交互式生成创建证书申请：</p></blockquote>

<pre><code>$ openssl req -new -key rsa-fd.key -out rsa-fd.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:ShangHai
Locality Name (eg, city) []:ShangHai
Organization Name (eg, company) [Internet Widgits Pty Ltd]:limo
Organizational Unit Name (eg, section) []:limo
Common Name (e.g. server FQDN or YOUR name) []:localhost
Email Address []:.

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:.
An optional company name []:.
$
</code></pre>

<p>其中<code>Common Name</code>指定证书保护的域名。</p>

<blockquote><p>使用openssl req查看证书申请内容：</p></blockquote>

<pre><code>Data:
        Version: 0 (0x0)
        Subject: C=CN, ST=ShangHai, L=ShangHai, O=limo, OU=limo, CN=localhost
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
            RSA Public Key: (2048 bit)
                Modulus (2048 bit):
                    00:c0:2b:11:a0:53:7d:fa:83:7f:29:2b:b5:dc:bc:
                Exponent: 65537 (0x10001)
        Attributes:
            a0:00
Signature Algorithm: sha1WithRSAEncryption
        7c:3d:47:49:d5:f7:c9:89:65:81:62:3d:bb:84:b8:ed:70:c4:
        e8:ba:ae:03:2e:af:3a:cb:31:07:e3:ef:57:a1:c7:a8:a6:c8:
</code></pre>

<blockquote><p>使用配置文件生成证书：</p></blockquote>

<p>配置文件内容如下：</p>

<pre><code>[req]
prompt = no
distinguished_name = dn
req_extensions     = ext

[dn]
CN      = localhost
O       = limo
L       = ShangHai
C       = CN

[ext]
subjectAltName = DNS:www.localhost.com,DNS:localhost
</code></pre>

<p>执行命令如下：</p>

<pre><code>$ openssl req -new -config rsa-fd.conf -key rsa-fd.key -out t.csr
</code></pre>

<h3>自签名证书</h3>

<p>如果已经有了csr，则执行以下命令创建证书：</p>

<pre><code>$ openssl x509 -req -days 365 -in rsa-fd.csr -signkey rsa-fd.key -out rsa-fd.crt
Signature ok
subject=/C=CN/ST=ShangHai/L=ShangHai/O=limo/OU=limo/CN=localhost
Getting Private key
</code></pre>

<h2><span id="practice"> 实践 </span></h2>

<blockquote><p>创建根CA证书</p></blockquote>

<ol>
<li><p>创建rsa密钥</p>

<pre><code class="`"> $ openssl genrsa -out ca.key 2048  
 Generating RSA private key, 2048 bit long modulus  
 ........+++  
 ..................................................+++  
 e is 65537 (0x10001)  
</code></pre></li>
<li><p>创建证书申请</p>

<pre><code> $ openssl genrsa -out ca.key 2048 -out ca.csr
 $ 
</code></pre></li>
<li><p>创建自签名证书</p>

<pre><code> $ openssl x509 -req -in ca.csr -signkey ca.key  -out ca.crt
 Signature ok
 subject=/C=CN/ST=ShangHai/L=ShangHai/O=li/OU=li/CN=RootCA
 Getting Private key
</code></pre></li>
</ol>


<blockquote><p>创建client密钥和证书</p></blockquote>

<ol>
<li><p>创建rsa密钥</p>

<pre><code class="`"> $ openssl genrsa -out client.key 2048
Generating RSA private key, 2048 bit long modulus
..................................+++
..........+++
e is 65537 (0x10001)
</code></pre></li>
<li><p>创建证书申请</p>

<pre><code> openssl req -new -key client.key -out client.csr
</code></pre></li>
<li><p>使用root CA签名client证书</p>

<pre><code> $ openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt
 Signature ok
 subject=/C=CN/ST=ShangHai/L=SH/O=li/OU=li/CN=localhost  
 Getting CA Private Key
</code></pre>

<p>需要增加<code>-CAcreateserial</code>参数否则报错</p></li>
</ol>


<blockquote><p>创建server密钥和证书</p></blockquote>

<p>方法同生成client密钥证书类似</p>

<blockquote><p>使用Go创建https server，并对客户端进行双向验证：</p></blockquote>

<pre><code>func HelloServer(w http.ResponseWriter, req *http.Request) {
    w.Header().Set("Content-Type", "text/plain")
    w.Write([]byte("This is an example server.\n"))
}

func main() {
    pool := x509.NewCertPool()
    caPath := "ca.crt"
    caCrt, err := ioutil.ReadFile(caPath)
    if err != nil {
        fmt.Println("ReadFile err ", err)
        return
    }
    ok := pool.AppendCertsFromPEM(caCrt);
    if !ok {
        fmt.Println("append err")
        return
    }

    fmt.Println(ok)
    tlsConfig := &amp;tls.Config{
        ClientCAs:pool,
        ClientAuth: tls.RequireAndVerifyClientCert,
    }
    server := http.Server{
        Addr:      ":443",
        TLSConfig: tlsConfig,
    }
    http.HandleFunc("/hello", HelloServer)
    err = server.ListenAndServeTLS("server.crt", "server.key")
    log.Fatal(err)
}
</code></pre>

<blockquote><p>使用Go创建https client</p></blockquote>

<pre><code>func main() {
    pool := x509.NewCertPool()
    caPath := "ca.crt"
    caCrt, err := ioutil.ReadFile(caPath)
    if err != nil {
        fmt.Println("ReadFile err:", err)
        return
    }
    pool.AppendCertsFromPEM(caCrt)
    cliCrt, err := tls.LoadX509KeyPair("client.crt", "client.key")
    if err != nil {
        fmt.Println("Loadx509keypair err:", err)
        return
    }
    tlsConfig := &amp;tls.Config{
        RootCAs:      pool,
        Certificates: []tls.Certificate{cliCrt},
        InsecureSkipVerify:true,
    }
    tr := http.Transport{TLSClientConfig: tlsConfig}
    client := http.Client{Transport: &amp;tr}
    url := "https://localhost/hello"
    resp, err := client.Get(url)
    if err != nil {
        panic(err)
    }
    data, err := ioutil.ReadAll(resp.Body)
    fmt.Println(string(data))
}
</code></pre>

<p><a href="https://github.com/jintao-zero/go-practice/tree/master/https">code</a></p>

<h2>参考</h2>

<ol>
<li><a href="">https权威指南</a></li>
<li><a href="http://tonybai.com/2015/04/30/go-and-https/">Go和HTTPS</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zookeeper实战]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/08/09/zookeepershi-zhan/"/>
    <updated>2017-08-09T15:57:12+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/08/09/zookeepershi-zhan</id>
    <content type="html"><![CDATA[<p>zookeeper实战记录</p>

<ul>
<li><a href="#setup">环境搭建</a></li>
<li><a href="#cmd">命令行操作</a></li>
<li><a href="#code">编程</a></li>
</ul>


<h2><span id="setup">环境搭建</span></h2>

<p>搭建适合生产环境使用的zookeeper集群，最好是大于等于3台机器</p>

<ol>
<li><p><a href="http://zookeeper.apache.org/releases.html">下载</a></p></li>
<li><p>解压</p>

<p> <code>tar xzf zookeeper***.tar.gz</code></p></li>
<li><p>修改配置文件<br/>
 进入解压目录conf子目录<br/>
 <code>cp zoo_sample.cfg zoo.cfg</code><br/>
 修改配置文件 <br/>
 设置相关参数：<br/>
 dataDir为zookeeper持久化数据存放目录   <br/>
 dataDir=/data/zookeeper
 配置集群中三台机器
 server.1=10.174.176.156:2888:3888
 server.2=10.168.106.149:2888:3888
 server.3=10.168.37.52:2888:3888<br/>
 需要在每台机器dataDir目录下建立myid文件，并将上面server后面对应的id写入myid文件中</p></li>
<li><p>启动程序<br/>
 bin/zkServer.sh start</p></li>
<li><p>查看日志文件<br/>
 tail -f zookeeper.out</p></li>
</ol>


<!-- more -->


<h2><span id="cmd">命令行操作</span></h2>

<p><code>bin/zkCli.sh -server 127.0.0.1:2181</code><br/>
连接zookeeper服务端。<br/>
查看<code>help</code>帮助命令：</p>

<pre><code>[zk: 127.0.0.1:2181(CONNECTED) 0] help  
ZooKeeper -server host:port cmd args
    stat path [watch]
    set path data [version]
    ls path [watch]
    delquota [-n|-b] path
    ls2 path [watch]
    setAcl path acl
    setquota -n|-b val path
    history
    redo cmdno
    printwatches on|off
    delete path [version]
    sync path
    listquota path
    rmr path
    get path [watch]
    create [-s] [-e] path data acl
    addauth scheme auth
    quit
    getAcl path
    close
    connect host:port
[zk: 127.0.0.1:2181(CONNECTED) 1]
</code></pre>

<p>新建节点：</p>

<pre><code>[zk: 127.0.0.1:2181(CONNECTED) 2] create /test  test_data
Created /test
[zk: 127.0.0.1:2181(CONNECTED) 3]
</code></pre>

<p>查看节点：</p>

<pre><code class="">[zk: 127.0.0.1:2181(CONNECTED) 4] ls /test
[]
[zk: 127.0.0.1:2181(CONNECTED) 5] get /test
test_data
cZxid = 0x10000002a
ctime = Wed Aug 09 16:26:43 CST 2017
mZxid = 0x10000002a
mtime = Wed Aug 09 16:26:43 CST 2017
pZxid = 0x10000002a
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 9
numChildren = 0
[zk: 127.0.0.1:2181(CONNECTED) 6]
</code></pre>
]]></content>
  </entry>
  
</feed>
