<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Program | jintao's blog]]></title>
  <link href="http://jintao-zero.github.io/blog/categories/program/atom.xml" rel="self"/>
  <link href="http://jintao-zero.github.io/"/>
  <updated>2017-01-01T22:58:49+08:00</updated>
  <id>http://jintao-zero.github.io/</id>
  <author>
    <name><![CDATA[jintao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang Cpu性能优化]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/01/01/golang-cpuxing-neng-you-hua/"/>
    <updated>2017-01-01T17:18:20+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/01/01/golang-cpuxing-neng-you-hua</id>
    <content type="html"><![CDATA[<p>本文根据<a href="https://blog.golang.org/profiling-go-programs">Profiling Go Programs</a>文章，进行演示如何利用Golang性能工具进行cpu性能统计和优化。</p>

<h2>准备工作</h2>

<p>1、Golang编译运行环境。</p>

<pre><code>go version go1.7 darwin/amd64
</code></pre>

<p>2、下载<a href="https://storage.googleapis.com/google-code-archive-source/v2/code.google.com/benchgraffiti/source-archive.zip">测试源码</a></p>

<pre><code>-rw-r--r-- 1 jintao staff 16594  1  1 16:58 havlak1.go
-rw-r--r-- 1 jintao staff 16597  1  1 16:58 havlak2.go
-rw-r--r-- 1 jintao staff 16832  1  1 16:58 havlak3.go
-rw-r--r-- 1 jintao staff 16905  1  1 16:58 havlak4.go
-rw-r--r-- 1 jintao staff 17501  1  1 16:58 havlak5.go
-rw-r--r-- 1 jintao staff  9467  1  1 16:58 havlak6.go
</code></pre>

<p>havlak1-6是源文件，以及优化后的源文件</p>

<h2>采集CPU性能数据</h2>

<p>优化程序之前，需要采集性能数据。多种方法可以使用，本文中采用的方法是引入<code>runtime/pprof</code>包，在代码文件main函数中添加如下代码片段:</p>

<pre><code>var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

func main() {
    flag.Parse()
    if *cpuprofile != "" {
        f, err := os.Create(*cpuprofile)
        if err != nil {
          log.Fatal(err)
        }
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
    ... 
</code></pre>

<p>利用flag包设置并解析cpuprofile参数，传入文件名，创建文件，调用<code>ppfof.StartCPUProfile</code>方法开始进行采样，并将采样结果保存在文件中，在程序返回之前调用<code>pprof.StopCPUProfile</code>方法确保所有采样数据刷新到结果文件中。</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ time ./havlak1 -cpuprofile=havlak1.prof
# of loops: 76000 (including 1 artificial root node)

real    0m21.768s
user    0m31.026s
sys 0m0.284s
</code></pre>

<p>产生性能文件havlak1.prof</p>

<!-- more -->


<h2>分析性能文件</h2>

<p><code>go tool pprof</code>是<a href="https://code.google.com/p/gperftools/wiki/GooglePerformanceTools">Google&rsquo;s pprof C++ profiler</a>一个变种，利用go tool pprof命令读取分析性能文件:</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ go tool pprof havlak1 havlak1.prof
Entering interactive mode (type "help" for commands)
(pprof)
</code></pre>

<p>输入<code>help</code>可以查看哪些可用命令，最常用是<code>top n</code>命令，查看前n个样本：</p>

<pre><code>(pprof) top
18750ms of 27430ms total (68.36%)
Dropped 95 nodes (cum &lt;= 137.15ms)
Showing top 10 nodes out of 80 (cum &gt;= 790ms)
      flat  flat%   sum%        cum   cum%
    3360ms 12.25% 12.25%     6790ms 24.75%  runtime.scanobject
    2890ms 10.54% 22.79%    14430ms 52.61%  main.FindLoops
    2470ms  9.00% 31.79%     2760ms 10.06%  runtime.mapaccess1_fast64
    1950ms  7.11% 38.90%     5140ms 18.74%  runtime.mapassign1
    1690ms  6.16% 45.06%     4080ms 14.87%  runtime.mallocgc
    1630ms  5.94% 51.00%     1630ms  5.94%  runtime.heapBitsForObject
    1580ms  5.76% 56.76%     3440ms 12.54%  main.DFS
    1250ms  4.56% 61.32%     1250ms  4.56%  runtime.memmove
    1140ms  4.16% 65.48%     1890ms  6.89%  runtime.greyobject
     790ms  2.88% 68.36%      790ms  2.88%  runtime/internal/atomic.Or8
(pprof)
</code></pre>

<p>启动性能分析时，Go程序每秒钟停止100次并对当前正在执行的goroutine调用栈进行采样。从上面数据可以看到，程序总执行时间为27430ms，采样top10函数一共占用18750ms（68.36%）。每行是一个函数的统计数据，前两列数据分别为采样时goroutine正在当前函数中的时间和占比，后两列为采样时此函数出现（正在执行或正在等待调用函数返回）的时间和占比。sum%列为前n行消耗时间之和对于总时间的占比。<code>main.FindLoops</code>函数正在执行的时间是2890ms占10.54%，在调用栈中出现的时间为14430ms占比为52.61%。<code>runtime.mapaccess1_fast64</code>执行的时间为2470ms占9.00%，在调用栈中出现的时间为2760ms占比为10.06%。使用-cum参数，按照第四第五列排序</p>

<pre><code>(pprof) top5 -cum
2.89s of 27.43s total (10.54%)
Dropped 95 nodes (cum &lt;= 0.14s)
Showing top 5 nodes out of 80 (cum &gt;= 14.43s)
  flat  flat%   sum%        cum   cum%
     0     0%     0%     22.79s 83.08%  runtime.goexit
     0     0%     0%     14.52s 52.93%  main.main
     0     0%     0%     14.52s 52.93%  runtime.main
     0     0%     0%     14.43s 52.61%  main.FindHavlakLoops
 2.89s 10.54% 10.54%     14.43s 52.61%  main.FindLoops
(pprof)
</code></pre>

<p>调用栈采样数据中关于函数间的调用关系可以有其他的有趣方式进行展现。比如<code>web</code>命令输出一个图片并用浏览器打开。<code>gv</code>命令写PostScript并在Ghostview中打开。</p>

<pre><code>(pprof) web
(pprof)
</code></pre>

<p>以下为图片部分截图： <br/>
<img src="/images/havlak1.png" alt="web" />
    图中每个方块对应一个单独函数，方块的大小与函数消耗的时间相对应。从X到Y的边显示X调用Y；边上的数字代表在被调用函数中消耗的时间。从图中我们可以发现在runtime.mapaccess1_fast64和runtime.mapassign1函数上消耗了较多时间。<br/>
    可以只显示包含某个函数的调用关系图：</p>

<pre><code>(pprof) web mapaccess
(pprof)
</code></pre>

<p><img src="/images/havlak1-mapaccess.png" alt="mapaccess" /><br/>
从上图我们可以发现主要是main.DFS和main.FindLoops函数调用了runtime.mapaccess<br/>
接下来重点分析<code>main.DFS</code>和<code>main.FindLoops</code>两个函数的时间消耗情况：</p>

<pre><code>(pprof) list DFS
Total: 27.43s
ROUTINE ======================== main.DFS in /Users/jintao/Project/opensource/benchgraffiti/havlak_new/havlak1.go
     1.58s      6.84s (flat, cum) 24.94% of Total
         .          .    235:   return false
         .          .    236:}
         .          .    237:
         .          .    238:// DFS - Depth-First-Search and node numbering.
         .          .    239://
      20ms       20ms    240:func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int {
     140ms      140ms    241:   nodes[current].Init(currentNode, current)
         .      310ms    242:   number[currentNode] = current
         .          .    243:
         .          .    244:   lastid := current
        1s         1s    245:   for _, target := range currentNode.OutEdges {
     160ms      1.31s    246:       if number[target] == unvisited {
      40ms      3.44s    247:           lastid = DFS(target, nodes, number, last, lastid+1)
         .          .    248:       }
         .          .    249:   }
     200ms      600ms    250:   last[number[currentNode]] = lastid
      20ms       20ms    251:   return lastid
         .          .    252:}
         .          .    253:
         .          .    254:// FindLoops
         .          .    255://
         .          .    256:// Find loops and build loop forest using Havlak's algorithm, which
(pprof)
</code></pre>

<p><code>list DFS</code> 会列出所有匹配DFS函数名的函数。从上面的代码我们发现耗时的语句分别在<code>242 246 247 250</code>行其中 247行是与DFS行数调用有关，其他三行都是与number变量有关，number是一个map数据结构，可以考虑改为采用slice，使用block number作为索引。</p>

<p>对文件进行修改，diff修改如下：</p>

<pre><code>240c240
&lt; func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int {
---
&gt; func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number []int, last []int, current int) int {
242c242
&lt;   number[currentNode] = current
---
&gt;   number[currentNode.Name] = current
246c246
&lt;       if number[target] == unvisited {
---
&gt;       if number[target.Name] == unvisited {
250c250
&lt;   last[number[currentNode]] = lastid
---
&gt;   last[number[currentNode.Name]] = lastid
271c271
&lt;   number := make(map[*BasicBlock]int)
---
&gt;   number := make([]int, size)
287c287
&lt;       number[bb] = unvisited
---
&gt;       number[bb.Name] = unvisited
315c315
&lt;               v := number[nodeV]
---
&gt;               v := number[nodeV.Name]
</code></pre>

<p>测试修改后的cpu性能：</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ go build havlak2.go
MacBook-Pro-2:havlak_new jintao$ time ./havlak2 -   cpuprofile=havlak2.prof
# of loops: 76000 (including 1 artificial root node)

real    0m11.685s
user    0m19.647s
sys 0m0.268s
</code></pre>

<p>再次使用go tool profile工具查看topn数据：</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ go tool pprof havlak2 havlak2.prof
Entering interactive mode (type "help" for commands)
(pprof) top
11460ms of 16610ms total (68.99%)
Dropped 92 nodes (cum &lt;= 83.05ms)
Showing top 10 nodes out of 87 (cum &gt;= 540ms)
   flat  flat%   sum%        cum   cum%
2950ms 17.76% 17.76%     5630ms 33.90%  runtime.scanobject
1500ms  9.03% 26.79%     4100ms 24.68%  runtime.mallocgc
1260ms  7.59% 34.38%     1260ms  7.59%  runtime.heapBitsForObject
1250ms  7.53% 41.90%     8700ms 52.38%  main.FindLoops
 920ms  5.54% 47.44%     1450ms  8.73%  runtime.greyobject
 920ms  5.54% 52.98%     2120ms 12.76%  runtime.mapassign1
 770ms  4.64% 57.62%      780ms  4.70%  runtime.heapBitsSetType
 760ms  4.58% 62.19%      760ms  4.58%  runtime.memmove
 590ms  3.55% 65.74%     1500ms  9.03%  runtime.makemap
 540ms  3.25% 68.99%      540ms  3.25%  runtime/internal/atomic.Or8
(pprof)
</code></pre>

<p>从上面可以看到<code>main.DFS</code>已经不在topn列表上，其他函数的时间也在显著下降。现在累计有24.68%的时间用在分配内存和垃圾回收（<code>runtime.mallocgc</code>）。下面需要使用进行内存性能优化。</p>

<h2>参考</h2>

<p>1、<a href="https://blog.golang.org/profiling-go-programs">Golang官方博客</a><br/>
2、<a href="https://code.google.com/p/gperftools/wiki/GooglePerformanceTools">C++ pprof</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang日期转化处理]]></title>
    <link href="http://jintao-zero.github.io/blog/2016/10/30/golangri-qi-zhuan-hua-chu-li/"/>
    <updated>2016-10-30T22:13:12+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2016/10/30/golangri-qi-zhuan-hua-chu-li</id>
    <content type="html"><![CDATA[<p>golang中time包提供了时间操作函数。</p>

<h2>获取时间</h2>

<pre><code>type Time struct {
    // contains filtered or unexported fields
}

func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time
func Now() Time
</code></pre>

<p>一个Time结构体代表一个纳米精度的时间实例。now函数可以获取当前时间：</p>

<pre><code>now := time.Now()
fmt.Println(now)
</code></pre>

<p>结果如下：</p>

<pre><code>2016-11-27 22:46:17.666418725 +0800 CST 
</code></pre>

<!-- more -->


<h2>格式化时间</h2>

<pre><code>func (t Time) Format(layout string) string
</code></pre>

<p>Format方法可以按照layout定义的格式格式化时间字符串。<br/>
Golang中以2006 01 02 03 04 05 分别定义年、月、日 时、分、秒字段，03的24表示法为15。<br/>
比如将当前时间格式化为YYYY-mm-dd hh:MM:ss，则layout为<code>2006-01-02 15:04:05</code></p>

<pre><code>now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))
</code></pre>

<p> 输出为：</p>

<pre><code>2016-11-27 22:56:40
</code></pre>

<p>控制精度的方法为在秒后面加0, 000、000000、000000000分别代表毫秒、微秒、纳秒：</p>

<pre><code>now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))
fmt.Println(now.Format("2006-01-02 15:04:05.000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000000"))
</code></pre>

<p>输出：</p>

<pre><code>now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))
fmt.Println(now.Format("2006-01-02 15:04:05.000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000000"))
</code></pre>

<h2>解析时间</h2>

<pre><code>func Parse(layout, value string) (Time, error)
func ParseInLocation(layout, value string, loc *Location) (Time, error)
</code></pre>

<p>Parse函数将格式化字符串解析为一个时间实例。<code>layout</code>定义了时间字符串的表现格式，比如：</p>

<pre><code>Mon Jan 2 15:04:05 -0700 MST 2006
</code></pre>

<p>当待解析时间字符串中没有时区时，<code>Parse</code>默认按照<code>UTC</code>时区解析时间。<code>ParseInLocation</code>按照loc参数指定的的location解析时间。</p>

<h2>定时器</h2>

<p>定时器通过<code>NewTimer</code>或者<code>AfterFunc</code>创建，用AfterFunc创建的定时器超时后，在定时器goroutine中调用func函数，其他定时器则通过C通道发送一个时间对象。</p>

<pre><code>type Timer struct {
    C &lt;-chan Time
    // contains filtered or unexported fields
}

func AfterFunc(d Duration, f func()) *Timer  
func NewTimer(d Duration) *Timer
</code></pre>

<p>定时器在使用过程中需要注意<code>Reset</code>和<code>Stop</code>方法的使用：</p>

<pre><code>func (t *Timer) Stop() bool
</code></pre>

<p>Stop方法用来停止定时器触发。停止定时器则返回true，如果定时器已经超时或者已经被停止则返回false。Stop方法不关闭定时器中的channel。<br/>
为了防止调用Stop方法后，定时器仍然触发，需要检查方法返回值并且读取定时器时间channel，代码片段：</p>

<pre><code>if !t.Stop() {
    &lt;-t.C
}

func (t *Timer) Reset(d Duration) bool
</code></pre>

<p><strong>需要特别注意的是，不要并发执行上面的代码。</strong></p>

<p>Reset修改定时器的超时时间为d。修改成功则返回true，如果定时器已经超时或者被停止则返回false。</p>

<pre><code>func (t *Timer) Reset(d Duration) bool
</code></pre>

<p>为了重复一个已经激活的定时器，需要先调用定时器<code>Stop</code>方法，如果定时器已经超时，则例如一下代码片段，先读取channel中的时间：</p>

<pre><code>if !t.Stop() {
    &lt;-t.C
}
t.Reset(d)
</code></pre>

<p><strong>需要特别注意的是，不要并发执行上面的代码。</strong>  <br/>
在读取通道和定时器超时之间存在竞态条件，所以几乎不可能正确使用Reset方法的返回值。Reset方法应该总是与Stop方法一起使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python解析json]]></title>
    <link href="http://jintao-zero.github.io/blog/2015/05/28/pythonjie-xi-json/"/>
    <updated>2015-05-28T15:21:55+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2015/05/28/pythonjie-xi-json</id>
    <content type="html"><![CDATA[<h1>JSON简介</h1>

<p>JSON(JavaScript Object Notation)是一个轻量级的数据交换格式。方便人类读写。方便机器解析和产生。它基于<a href="http://javascript.crockford.com/">JavaScript Programming Language</a>的子集，<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">Standard ECMA-262 3rd Edition - December 1999.</a>。JSON使用完全独立于各种语言的文本格式，但是也使用了类似C语言家族的习惯，包括C,C++,C#,Java,JavaScript,Perl,Python以及其他语言。这些特性使得JSON成为理想的数据交换语言。</p>

<p>JSON基于两种结构：</p>

<ul>
<li>一个name/value对集合。在各种语言中，这种集合被认为是一个对象，记录，结构体，字典，哈希表，有键列表，或者关联数组</li>
<li>一个有序列表。在大多数语言中，这种列表被认为是一个数组，向量，列表，或者序列。</li>
</ul>


<p>这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。
关于JSON格式中各个基本类型和数据结构的详细描述，可以参考<a href="http://www.json.org/">json</a></p>

<p>  <!-- more --></p>

<h1>Python JSON模块</h1>

<h2>类</h2>

<p>类JSONDecoder</p>

<pre><code>class JSONDecoder(__builtin__.object)   
</code></pre>

<p>将JSON格式解码为Python对应类型，下面是对应关系：</p>

<pre><code>    | JSON          | Python            |
    +===============+===================+
    | object        | dict              |
    +---------------+-------------------+
    | array         | list              |
    +---------------+-------------------+
    | string        | unicode           |
    +---------------+-------------------+
    | number (int)  | int, long         |
    +---------------+-------------------+
    | number (real) | float             |
    +---------------+-------------------+
    | true          | True              |
    +---------------+-------------------+
    | false         | False             |
    +---------------+-------------------+
    | null          | None              |
    +---------------+-------------------+
</code></pre>

<p>类JSONEncoder</p>

<pre><code>class JSONEncoder(__builtin__.object)
</code></pre>

<p>将Python中的类型转换为JSON格式，下面是对应关系：</p>

<pre><code>    | Python            | JSON          |
    +===================+===============+
    | dict              | object        |
    +-------------------+---------------+
    | list, tuple       | array         |
    +-------------------+---------------+
    | str, unicode      | string        |
    +-------------------+---------------+
    | int, long, float  | number        |
    +-------------------+---------------+
    | True              | true          |
    +-------------------+---------------+
    | False             | false         |
    +-------------------+---------------+
    | None              | null          |
    +-------------------+---------------+
</code></pre>

<h2>函数</h2>

<p>json模块对外提供了4个函数来进行json格式的编码、解码工作：<br/>
1、dump函数</p>

<pre><code>dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)
</code></pre>

<p>序列化<code>obj</code>为json格式流保存到fp中（fp是一个支持.write()函数的类文件对象）</p>

<ul>
<li><p>skipkeys<br/>
如果<code>skipkeys</code>为true，字典（<code>dict</code>）中键不为基本类型（<code>str</code>,<code>unicode</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>bool</code>,<code>None</code>）时，键值对将会被过滤掉，否则产生<code>TypeError</code>异常</p></li>
<li><p>ensure_ascii  <br/>
如果<code>ensure_ascii</code>为true(默认为true)，输出中的所有非ASCII字符都转义为<code>\uXXXX</code>序列，并且返回值序列只包含ASCII序列。</p></li>
<li><p>check_circular<br/>
如果check_circular为false，将会忽略对容器类型的循环引用检测，进而导致<code>OverflowError</code></p></li>
<li><p>allow_nan<br/>
如果<code>allow_nan</code>为false，序列化float类型无限值（<code>nan</code>,<code>inf</code>,<code>-inf</code>）时，将会导致<code>ValueError</code>错误</p></li>
<li><p>indent<br/>
如果indent指定为非负数值，JSON数组和对象成员将会以indent缩进整齐打印。</p></li>
<li><p>separators<br/>
如果separators是一个<code>(item_separator, dict_separator)</code>元组，它就会用来替代缺省的<code>(', ', ': ')</code>分隔符。<code>(',', ':')</code>是最长用的压缩分隔符</p></li>
<li>encoding
json文本字符编码，缺省为UTF-8</li>
<li>default(obj)<br/>
default(obj)是一个函数返回obj的序列化版本或者产生TypeError。</li>
<li>sort_keys<br/>
如果为True(sort_keys默认为False)，字典将会按照key排序输出。</li>
</ul>


<p>2、dumps函数</p>

<pre><code>dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)
</code></pre>

<p>序列化<code>obj</code>对象为JSON格式的字符串。
各个参数的意思于上面dump函数相同</p>

<p>3、load函数</p>

<pre><code>load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
</code></pre>

<p>load函数从fp引用的对象中读取JSON格式字符串，反序列化为Python对象。</p>

<ul>
<li>encoding<br/>
如果fp的内容不是基于ASCII字符集，那么需要指定encoding为相应编码集。</li>
<li>object_hook<br/>
object_hook可选参数被用来代替Python中的<code>dict</code>类型解析json序列串中的对象。这一特性被用来定制解码器。</li>
<li>object_pairs_hook<br/>
object_pairs_hook作为可选函数，被用来解析有序对，如果同时设置了object_pairs_hook和object_hook参数，优先使用object_pairs_hook函数。</li>
</ul>


<p>4、loads</p>

<pre><code>loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
</code></pre>

<p>loads函数将s字符串反序列化为Python对象。</p>

<ul>
<li><p>parse_float<br/>
如果指定parse_float参数，它被用来反序列化float字符串，缺省为float(num_str)。</p></li>
<li><p>parse_int<br/>
如果指定parse_int参数，它被用来反序列化int字符串，缺省为int(num_str)</p></li>
<li><p>parse_constant<br/>
如果指定parse_constant参数，它将被用来返序列化-Infinity, Infinity, NaN, null, true, false.</p></li>
</ul>


<h2>示例</h2>

<p>1、编码Python基本类型</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
'["foo", {"bar": ["baz", null, 1.0, 2]}]'
&gt;&gt;&gt; print json.dumps("\"foo\bar")
"\"foo\bar"
&gt;&gt;&gt; print json.dumps(u'\u1234')
"\u1234"
&gt;&gt;&gt; print json.dumps('\\')
"\\"
&gt;&gt;&gt; print json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)
{"a": 0, "b": 0, "c": 0}
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; io = StringIO()
&gt;&gt;&gt; json.dump(['streaming API'], io)
&gt;&gt;&gt; io.getvalue()
'["streaming API"]'   
</code></pre>

<p>2、压缩编码</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; json.dumps([1,2,3,{'4': 5, '6': 7}], sort_keys=True, separators=(',',':'))
'[1,2,3,{"4":5,"6":7}]'
</code></pre>

<p>3、优雅打印</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; print json.dumps({'4': 5, '6': 7}, sort_keys=True,
...                  indent=4, separators=(',', ': '))
{
    "4": 5,
    "6": 7
}
</code></pre>

<p>4、反序列化JSON</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; obj = [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]
&gt;&gt;&gt; json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]') == obj
True
&gt;&gt;&gt; json.loads('"\\"foo\\bar"') == u'"foo\x08ar'
True
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; io = StringIO('["streaming API"]')
&gt;&gt;&gt; json.load(io)[0] == 'streaming API'
True
</code></pre>

<p>5、定制JSON对象反序列化</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; def as_complex(dct):
...     if '__complex__' in dct:
...         return complex(dct['real'], dct['imag'])
...     return dct
...
&gt;&gt;&gt; json.loads('{"__complex__": true, "real": 1, "imag": 2}',
...     object_hook=as_complex)
(1+2j)
&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; json.loads('1.1', parse_float=Decimal) == Decimal('1.1')
True
</code></pre>

<p>6、定制JSON对象序列化</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; def encode_complex(obj):
...     if isinstance(obj, complex):
...         return [obj.real, obj.imag]
...     raise TypeError(repr(o) + " is not JSON serializable")
...
&gt;&gt;&gt; json.dumps(2 + 1j, default=encode_complex)
'[2.0, 1.0]'
&gt;&gt;&gt; json.JSONEncoder(default=encode_complex).encode(2 + 1j)
'[2.0, 1.0]'
&gt;&gt;&gt; ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))
'[2.0, 1.0]'
</code></pre>

<p>7、使用json.tool校验和打印json</p>

<pre><code>$ echo '{"json":"obj"}' | python -m json.tool
{
    "json": "obj"
}
$ echo '{ 1.2:3.4}' | python -m json.tool
Expecting property name enclosed in double quotes: line 1 column 3 (char 2)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Property 属性用法]]></title>
    <link href="http://jintao-zero.github.io/blog/2015/04/05/python-property-shu-xing-yong-fa/"/>
    <updated>2015-04-05T17:26:05+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2015/04/05/python-property-shu-xing-yong-fa</id>
    <content type="html"><![CDATA[<p>python提供了一个property类：</p>

<pre><code>class property([fget[, fset[, fdel[, doc]]]])
</code></pre>

<p>property类为新式类（继承object）返回property属性<br/>
fget函数用来获取属性值。fset设置属性值。fdel用来删除属性。doc为属性创建docstring。<br/>
property的典型应用是应用一个被管理的属性x：</p>

<pre><code>class C(object):
def __init__(self):
    self._x = None

def getx(self):
    return self._x

def setx(self, value):
    self._x = value

def delx(self):
    del self._x

x = property(getx, setx, delx, "I'm the 'x' property.")
</code></pre>

<p>如果c是类C的实例，c.x将会调用getx，c.x＝value将会调用setx，del c.x会调用用delx</p>

<p>将property 用作decorrator可以定义只读properties：</p>

<pre><code>class Parrot(object):
    def __init__(self):
        self._voltage = 100000

    @property
    def voltage(self):
        """Get the current voltage."""
        return self._voltage
</code></pre>

<p>@property修饰符将voltage函数变为voltage函数的同名属性的只读getter函数，同时这只这个属性的docstring与voltage函数相同</p>

<p>一个property对象具有getter，setter和deleter方法可以用当作修饰符将属性同名函数变为属性对应的访问函数，下面是例子：</p>

<pre><code>class C(object):
    def __init__(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x
</code></pre>

<p>上面的用法与第一个列子相同，需要注意的是几个函数的名字都相同</p>
]]></content>
  </entry>
  
</feed>
