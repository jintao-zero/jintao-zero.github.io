<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dev | jintao's blog]]></title>
  <link href="http://jintao-zero.github.io/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://jintao-zero.github.io/"/>
  <updated>2017-06-24T17:43:13+08:00</updated>
  <id>http://jintao-zero.github.io/</id>
  <author>
    <name><![CDATA[jintao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang加两边读锁导致程序死锁问题分析]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/06/20/golangjia-liang-bian-du-suo-dao-zhi-cheng-xu-si-suo-wen-ti-ji-lu/"/>
    <updated>2017-06-20T21:42:04+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/06/20/golangjia-liang-bian-du-suo-dao-zhi-cheng-xu-si-suo-wen-ti-ji-lu</id>
    <content type="html"><![CDATA[<p>golang程序使用读写锁对共享数据进行互斥保护时，注意在同一程序调用栈不要对锁进行多次加锁，这样会导致程序死锁，如下的代码片段就会导致程序死锁：</p>

<pre><code>import (
"sync"
"fmt"
"time"
_ "net/http/pprof"
"net/http"
)

var mutex sync.RWMutex

func f()  {
    fmt.Println("f begin to get Rlock ")
    mutex.RLock()
    defer mutex.RUnlock()
    fmt.Println("f get Rlock suc")
}

func main() {
    mutex.RLock()
    fmt.Println("main get RLock suc")
    defer mutex.RUnlock()

    go http.ListenAndServe(":6060", nil)
    go func() {
        fmt.Println("other goroutine begin to get write lock")
        mutex.Lock()
        defer mutex.Unlock()
        fmt.Println("other goroutine get write lock suc“)
    }()
    time.Sleep(time.Second)
    f()
}
</code></pre>

<p>程序执行结果如下：</p>

<pre><code>MacBook-Pro-2:sync jintao$ go run main.go 
main get RLock suc
other goroutine begin to get write lock
f begin to get Rlock
</code></pre>

<!-- more -->


<p>通过pprof工具查看相关goroutine调用栈：<br/>
main goroutine阻塞在获取读锁的位置：</p>

<pre><code>1 @ 0x102dfca 0x102e0ae 0x103e5a1 0x103e1a4 0x1060869 0x13119c6 0x1311bd7 0x102db7a 0x1059c01
#   0x103e1a3   sync.runtime_Semacquire+0x33    /usr/local/go/src/runtime/sema.go:47
#   0x1060868   sync.(*RWMutex).RLock+0x48  /usr/local/go/src/sync/rwmutex.go:43
#   0x13119c5   main.f+0xa5         /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:15
#   0x1311bd6   main.main+0x136         /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:33
#   0x102db79   runtime.main+0x209      /usr/local/go/src/runtime/proc.go:185
</code></pre>

<p>子goroutine阻塞在获取写锁的位置：</p>

<pre><code>1 @ 0x102dfca 0x102e0ae 0x103e5a1 0x103e1a4 0x106098e 0x1311cb6 0x1059c01
#   0x103e1a3   sync.runtime_Semacquire+0x33    /usr/local/go/src/runtime/sema.go:47
#   0x106098d   sync.(*RWMutex).Lock+0x6d   /usr/local/go/src/sync/rwmutex.go:91
#   0x1311cb5   main.main.func1+0xa5        /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:28
</code></pre>

<p>通过上面的调用栈，我们发现main goroutine在第21行已经获取了读锁，当在调用的函数<code>f</code>第15行再次尝试获取读锁时，程序阻塞。创建的goroutine在第28行尝试获取写所时，协程阻塞。</p>

<h2>分析</h2>

<p>这个是读写锁的一个标准行为。在
<a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Wikipedia &ldquo;Readers–writer lock&rdquo;</a>词条中对读写锁进行了介绍，在<code>Priority policies</code>一节中对<code>reader</code>和<code>writer</code>加锁时的优先级策略进行了说明，不同的优先级策略会给并发和死锁带来不同的影响：</p>

<ul>
<li>读优先策略 <br/>
  读优先允许最大并发，但是如果读并发太多，可能导致写饥饿。<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwji0rOAh9bUAhUW12MKHYx9CvUQFggyMAI&amp;url=http%3A%2F%2Fwww.beck-shop.de%2Ffachbuch%2Fleseprobe%2F9783642320262_Excerpt_001.pdf&amp;usg=AFQjCNEskoEL2n3HKpHGYVWc_XpU4z90nw">Concurrent Programming: Algorithms, Principles, and Foundations</a></li>
<li>写优先策略<br/>
  写优先策略可以避免上面读优先导致的写锁饥饿问题，如果有一个写锁着在等待，系统将会组织任何新reader加读锁成功，一旦当前已经获取的读锁释放完后，即会成功获取写锁。写优先策略相比较与读优先策略，会降低系统的并发性能。相对于读优先策略，写优先策略在实现上的效率要低，因为在获取或者释放读锁或者写锁时，都要操作多个互斥锁。</li>
<li>不指定优先级策略
  这种策略在一定场景下的效率更高</li>
</ul>


<p>从上面Wikipedia关于读写锁的说明看，golang中关于读写锁使用的是写优先策略，下面查看源码，对源码进行分析</p>

<h2>源码解析</h2>

<p>读写锁实现在sync/rwmutex.go文件中</p>

<pre><code>type RWMutex struct {
    w           Mutex  // 获取写锁时，必须获取的互斥量
    writerSem   uint32 // 写锁信号量
    readerSem   uint32 // 读锁信号量
    readerCount int32  // 目前获取的读锁个数
    readerWait  int32  // 需要等待reader释放锁个数
}
</code></pre>

<p><code>加载读锁：</code></p>

<pre><code>// RLock locks rw for reading.
func (rw *RWMutex) RLock() {
    if race.Enabled {
        _ = rw.w.state
        race.Disable()
    }
    if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 {
        // A writer is pending, wait for it.
        runtime_Semacquire(&amp;rw.readerSem)
    }
    if race.Enabled {
        race.Enable()
        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))
    }
}
</code></pre>

<p>每次获取读锁时，都对readerCount计数器进行加1，如果加1后值为负，那么说明有人正在获取写锁。等待readerSem信号量变为正</p>

<p><code>释放读锁：</code></p>

<pre><code>func (rw *RWMutex) RUnlock() {
    if race.Enabled {
        _ = rw.w.state
        race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))
        race.Disable()
    }
    if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 {
        if r+1 == 0 || r+1 == -rwmutexMaxReaders {
            race.Enable()
            panic("sync: RUnlock of unlocked RWMutex")
        }
        // A writer is pending.
        if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 {
            // The last reader unblocks the writer.
            runtime_Semrelease(&amp;rw.writerSem)
        }
    }
    if race.Enabled {
        race.Enable()
    }
}
</code></pre>

<p>释放写锁时，对readerCount减1，说明获取释放一个读锁，如果最新值为负，那么说明有人正在尝试获取写锁，readerWait记录了写锁需要等待的读锁个数，此时将readerWait个数减1，如果个素减为0，说明写锁正在等待的所有reader都已经释放读锁，此时可以释放写锁信号量，让程序获取写锁。</p>

<p><code>获取写锁：</code></p>

<pre><code>func (rw *RWMutex) Lock() {
    if race.Enabled {
        _ = rw.w.state
        race.Disable()
    }
    // First, resolve competition with other writers.
    rw.w.Lock()
    // Announce to readers there is a pending writer.
    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    // Wait for active readers.
    if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 {
        runtime_Semacquire(&amp;rw.writerSem)
    }
    if race.Enabled {
        race.Enable()
        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))
        race.Acquire(unsafe.Pointer(&amp;rw.writerSem))
    }
}
</code></pre>

<p>获取写锁时，首先获取互斥锁，这样其他写锁必须等待。然后设置读锁个数为负值，这样后面的reader就无法获取到读锁。如果读锁没有释放，则等待写锁信号量变为正。</p>

<p><code>释放写锁：</code></p>

<pre><code>func (rw *RWMutex) Unlock() {
    if race.Enabled {
        _ = rw.w.state
        race.Release(unsafe.Pointer(&amp;rw.readerSem))
        race.Release(unsafe.Pointer(&amp;rw.writerSem))
        race.Disable()
    }

    // Announce to readers there is no active writer.
    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)
    if r &gt;= rwmutexMaxReaders {
        race.Enable()
        panic("sync: Unlock of unlocked RWMutex")
    }
    // Unblock blocked readers, if any.
    for i := 0; i &lt; int(r); i++ {
        runtime_Semrelease(&amp;rw.readerSem)
    }
    // Allow other writers to proceed.
    rw.w.Unlock()
    if race.Enabled {
        race.Enable()
    }
}
</code></pre>

<p>释放写锁时，将等待获取读锁的个数变为实际值，根据等待获取读锁的个数，释放读锁信号量。</p>

<h2>结论</h2>

<p>根据上面对读写锁源码的分析，我们可以看到golang中读写锁是使用写锁优先策略的，博文开头的例子中，main主协程在已经获取读锁的情况，又尝试第二次获取读锁，因为已经创建了一个子协程在获取写锁，那么第二次获取读锁操作将被阻塞，这样就导致主协程无法释放第一次获取的读锁，从而子协程获取写锁失败，这样整个程序两个写成处于死锁状态。</p>

<h2>参考</h2>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/4sx5pPp8gFw">Lock re-accquision in sync forbiden</a></li>
<li><a href="https://golang.org/pkg/sync/#RWMutex.Lock">Package sync</a></li>
<li><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Readers–writer lock</a></li>
<li><a href="https://stackoverflow.com/questions/30547916/goroutine-blocks-when-calling-rwmutex-rlock-twice-after-an-rwmutex-unlock">goroutine blocks when calling RWMutex RLock twice after an RWMutex Unlock</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go代码走读规范]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/06/14/godai-ma-zou-du-gui-fan/"/>
    <updated>2017-06-14T19:27:11+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/06/14/godai-ma-zou-du-gui-fan</id>
    <content type="html"><![CDATA[<p>Go代码走读时注意点，非代码规范：</p>

<ul>
<li><a href="#gofmt">Gofmt</a></li>
<li><a href="#Comment%20Sentences">Comment Sentences</a></li>
</ul>


<h2><span id="Gofmt">Gofmt</span></h2>

<p>使用<a href="https://golang.org/cmd/gofmt/">gofmt</a>工具修复大多数代码风格问题。机会所有Go代码都是用<code>gofmt</code>进行格式化。剩下的非机器可以格式化的代码风格将在本篇文章中进行说明。<br/>
一个替代工具是<code>goimports</code>，它是<code>gofmt</code>工具的一个超集，它会自动增加或者删除引入包行。</p>

<h2><span id="Comment Sentences">Comment Sentences</span></h2>

<p>查看<a href="https://golang.org/doc/effective_go.html#commentary">https://golang.org/doc/effective_go.html#commentary</a>，声明的注释应该占完整行，这样在将注释抽取到godoc文档时可以更好的格式化。注释应该以被注释声明开始，存在结束：</p>

<pre><code>// Request represents a request to run a command.
type Request struct { ...

// Encode writes the JSON encoding of req to w.
func Encode(w io.Writer, req *Request) { ...
</code></pre>

<h2><span id="Contexts">Contexts</span></h2>

<p><code>context.Context</code>类型实例在API和进程边界中传递安全证书、跟踪信息、超时期限和取消信号。Go程序在从RPC或者HTTP请求开始到输出请求的整个函数调用链过程中显示传递Context实例。  <br/>
大部分函数使用Context作为第一个参数：</p>

<pre><code>func F(ctx context.Context, /* other arguments */) {}
</code></pre>

<p>如果一个函数不是请求特化的话，可以使用context.Background，即使你觉得不必要也宁可传递一个Context实例。默认情况是传递一个Context上下文，除非有更好的理由来使用<code>context.Background</code>。<br/>
不要在结构体类型中添加<code>Context</code>成员，在结构体类型的所有需要使用Context的方法中添加一个ctx参数，用来传递Context。一个特殊情况是如果这些方法需要满足标准库或者第三方库中的接口。<br/>
不要在函数声明中使用特定Context类型或者使用非Context接口。<br/>
除非真的需要，否则通过参数，全局变量或者其他方法传递应用程序数据。<br/>
Context是不可变的，所以可在多个调用中传递同一个ctx共享同样的最后期限、取消信号、资格认证和跟踪等等。</p>

<h2><span id="Copying"> Copying</span></h2>

<p>避免非预期的别名使用，当从其他包拷贝结构体时需要小心。比如，bytes.Buffer类型包含一个<code>[]byte</code>数组，当保存的字符串比较小时，内部<code>[]byte</code>数组就比较小。如果拷贝一个<code>Buffer</code>，新旧Buffer类型变量中的数组就发生了混淆，这样接下来对于两个Buffer对象的使用将产生不可预知的情况。<br/>
总的来说，如果一个类型<code>T</code>，它的方法都与<code>*T</code>想对象，那就不要复制这个类型的变量。</p>

<h2><span id="Declaring Empty Slices"> Declaring Empty Slices</span></h2>

<p>声明一个空切片时，使用下面方式：</p>

<pre><code>var t []string
</code></pre>

<p>而不是</p>

<pre><code>t := []string{}
</code></pre>

<p>前者声明一个nil切片，后者定义一个长度为0的非nil切片。两种方式定义的切片<code>len</code>和<code>cap</code>的值都为0，建议使用前者。</p>

<p>一些场景下建议使用后者定义空切片，比如将对象序列化为JSON格式时，<code>nil</code>序列化为<code>null</code>，<code>[]string{}</code>序列化为<code>[]</code>。</p>

<p>设计接口时，避免nil切片，非nil切片和长度为0的切片产生差异，否则会产生微妙的错误。</p>

<p>更多关于Go中nil的讨论见：<a href="https://www.youtube.com/watch?v=ynoY2xz-F8s">Understanding Nil</a></p>

<h2><span id="Crypto Rand">Crypto Rand</span></h2>

<p>即使只使用一次，也不要使用<code>math/rand</code>生成key。没有种子，生成是可预测的。使用<code>time.Nanoseconds()</code>设置种子，只有一点熵。可替换方法是，使用<code>crypto/rand</code>，如果需要文本，打印为十六进制或者base64编码。</p>

<pre><code>import (
"crypto/rand"
// "encoding/base64"
// "encoding/hex"
"fmt"
)

func Key() string {
    buf := make([]byte, 16)
    _, err := rand.Read(buf)
if err != nil {
    panic(err)  // out of randomness, should never happen
}
return fmt.Sprintf("%x", buf)
// or hex.EncodeToString(buf)
// or base64.StdEncoding.EncodeToString(buf)    
}
</code></pre>

<h2><span id="Doc Comments">Doc Comments</span></h2>

<p>所有顶级，对外提供的名称应该有文档注释，一些重要的非对外提供的类型和函数定名也需要有注释。更多关于注释的信息参考：<a href="https://golang.org/doc/effective_go.html#commentary">https://golang.org/doc/effective_go.html#commentary</a></p>

<h2><span id="Don't Panic">Don&rsquo;t Panic</span></h2>

<p>关于错误处理参考：<a href="https://golang.org/doc/effective_go.html#errors">https://golang.org/doc/effective_go.html#errors</a>。不要使用<code>panic </code>处理普通错误。使用error和多返回值。</p>

<h2><span id="Error Strings">Error Strings</span></h2>

<p>错误字符串不应该大写，除非是以名词或者缩写开头，因为错误信息通常跟在其他信息后面。使用<code>fmt.Errorf("something bad")</code>，而不是<code>fmt.Errorf("Something bad")</code>，所以<code>log.Printf("Reading %s: %v", filename, err)</code>格式化的信息中不会在中间出现一个可以的大写字符。</p>

<h2><span id="Examples">Examples</span></h2>

<p>当添加一个新包时，包含使用示例：一个可运行示例，或者一个简单测试演示一个完整调用顺序。<br/>
更多信息参考：<a href="https://blog.golang.org/examples">testable Example() functions</a>。</p>

<h2><span id="Goroutine Lifetimes">Goroutine Lifetimes</span></h2>

<p>当创建goroutine时，需要对它是否退出和什么时间退出非常清楚。</p>

<p>goroutine阻塞在发送或者接收通道时可能会导致泄漏：垃圾收集不会结束这样的goroutine。</p>

<p>即使这些goroutine没有泄漏，这样的goroutine有可能导致微妙的不易定位的问题。向已经关闭的通道发送数据会导致panic。</p>

<p>保持并发执行的代码足够简单，这样goroutine的声明周期更明显。 如果不能这样的话，对goroutine的退出时机进行注释。</p>

<h2><span id="Handle Errors">Handle Errors</span></h2>

<p>查看错误处理<a href="https://golang.org/doc/effective_go.html#errors">https://golang.org/doc/effective_go.html#errors</a>，不要使用<code>_</code>丢弃错误。如果一个函数返回错误，对返回值进行检查。处理错误，返回。如果是异常情况，则panic。</p>

<h2><span id="Imports">Import</span></h2>
]]></content>
  </entry>
  
</feed>
