<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Golang | jintao's blog]]></title>
  <link href="http://jintao-zero.github.io/blog/tags/golang/atom.xml" rel="self"/>
  <link href="http://jintao-zero.github.io/"/>
  <updated>2017-01-14T21:23:28+08:00</updated>
  <id>http://jintao-zero.github.io/</id>
  <author>
    <name><![CDATA[jintao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[golang go命令详解]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/01/13/golang-goming-ling-xiang-jie/"/>
    <updated>2017-01-13T19:17:12+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/01/13/golang-goming-ling-xiang-jie</id>
    <content type="html"><![CDATA[<h1>go命令</h1>

<p><a href="#compile">Compile packages and dependencies</a>    <br/>
<a href="#clean">Remove object files</a></p>

<p><code>Go</code>工具用来管理Go语音源代码。
使用：</p>

<pre><code>go command [arguments]
</code></pre>

<p>命令为：</p>

<pre><code>build       compile packages and dependencies
clean       remove object files
doc         show documentation for package or symbol
env         print Go environment information
fix         run go tool fix on packages
fmt         run gofmt on package sources
generate    generate Go files by processing source
get         download and install packages and dependencies
install     compile and install packages and dependencies
list        list packages
run         compile and run Go program
test        test packages
tool        run specified go tool
version     print Go version
vet         run go tool vet on packages
</code></pre>

<p>使用<code>go help [command]</code>查看命令相信信息。<br/>
更多topic：</p>

<pre><code>c           calling between Go and C
buildmode   description of build modes
filetype    file types
gopath      GOPATH environment variable
environment environment variables
importpath  import path syntax
packages    description of package lists
testflag    description of testing flags
testfunc    description of testing functions
</code></pre>

<p>使用<code>go help [topic]</code>查看topic帮助信息</p>

<!-- more -->


<h2><a name="compile"></a>编译包及其依赖</h2>

<p>使用：</p>

<pre><code>go build [-o output] [-i] [build flags] [packages]
</code></pre>

<p><code>Build</code>编译包，及其依赖，但是不进行安装。</p>

<p>如果输入的是一些.go文件，build认为是编译由这些文件组成的单独包。
当单独编译main包时，build将可执行程序写入输出文件，输出文件以列出的第一个.go源文件名称命名，或者以main包源文件所在的文件夹名称命名，Windows环境下，可执行成后后缀为.exe。</p>

<p>当编译多个包或者一个非main包，build命令只是编译这些包，丢弃结果文件，只是查看包是否能够编译成功。</p>

<p>编译包时，build忽略以<code>_test.go</code>为后缀的文件。</p>

<p><code>-o</code>参数，可以用来指定编译结果存放路径。<br/>
<code>-i</code>参数，设置将目标程序依赖的包进行安装。</p>

<p>build 标志是<code>build,clean,get,install,list,run,test</code>共享的：</p>

<pre><code>-a
    force rebuilding of packages that are already up-to-date.
-n
    print the commands but do not run them.
-p n
    the number of programs, such as build commands or
    test binaries, that can be run in parallel.
    The default is the number of CPUs available.
-race
    enable data race detection.
    Supported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.
-msan
    enable interoperation with memory sanitizer.
    Supported only on linux/amd64,
    and only with Clang/LLVM as the host C compiler.
-v
    print the names of packages as they are compiled.
-work
    print the name of the temporary work directory and
    do not delete it when exiting.
-x
    print the commands.

-asmflags 'flag list'
    arguments to pass on each go tool asm invocation.
-buildmode mode
    build mode to use. See 'go help buildmode' for more.
-compiler name
    name of compiler to use, as in runtime.Compiler (gccgo or gc).
-gccgoflags 'arg list'
    arguments to pass on each gccgo compiler/linker invocation.
-gcflags 'arg list'
    arguments to pass on each go tool compile invocation.
-installsuffix suffix
    a suffix to use in the name of the package installation directory,
    in order to keep output separate from default builds.
    If using the -race flag, the install suffix is automatically set to race
    or, if set explicitly, has _race appended to it.  Likewise for the -msan
    flag.  Using a -buildmode option that requires non-default compile flags
    has a similar effect.
-ldflags 'flag list'
    arguments to pass on each go tool link invocation.
-linkshared
    link against shared libraries previously created with
    -buildmode=shared.
-pkgdir dir
    install and load all packages from dir instead of the usual locations.
    For example, when building with a non-standard configuration,
    use -pkgdir to keep generated packages in a separate location.
-tags 'tag list'
    a list of build tags to consider satisfied during the build.
    For more information about build tags, see the description of
    build constraints in the documentation for the go/build package.
-toolexec 'cmd args'
    a program to use to invoke toolchain programs like vet and asm.
    For example, instead of running asm, the go command will run
    'cmd args /path/to/asm &lt;arguments for asm&gt;'.
</code></pre>

<p>上面列的参数标志接收以空格为分隔符的字符串列表。如果参数中包含空格，那么需要将参数用单引号或者双引号包裹。</p>

<p>使用<code>go help packages</code>查看更多关于包的信息，使用<code>go help gopath</code>查看更多关于编译和安装路径的信息，使用<code>go help c</code>查看更多关于Go和C/C++调用的帮助信息。</p>

<p><code>Build</code>依附于<code>go help gopath</code>中描述的惯例。并不是所有项目遵从惯例。使用不同构建惯例或者构建系统可能会选择使用更低层的构建工具如<code>go tool compile</code>和<code>go tool link</code>。</p>

<h2><a name="clean"></a>删除目标文件</h2>

<p>使用：</p>

<pre><code>go clean [-i] [-r] [-n] [-x] [build flags] [packages]
</code></pre>

<p>将包源代码路径中的目标文件删除。<code>go</code>命令通常在临时目录构建目标对象，所以<code>go clean</code>通常用来删除其他工具或者手动执行<code>go build</code>生成的结果文件。</p>

<p>特别的，clena命令将包源码路径下生成的如下文件删除：</p>

<pre><code>_obj/            old object directory, left from Makefiles
_test/           old test directory, left from Makefiles
_testmain.go     old gotest file, left from Makefiles
test.out         old test log, left from Makefiles
build.out        old test log, left from Makefiles
*.[568ao]        object files, left from Makefiles

DIR(.exe)        from go build
DIR.test(.exe)   from go test -c
MAINFILE(.exe)   from go build MAINFILE.go
*.so             from SWIG
</code></pre>

<p><code>-i</code>参数指定go clean 命令将go install命令安装的包文件或者二进制文件删除。 <br/>
<code>-n</code>参数指定go clean把要执行的删除命令打印，但是不实际执行。<br/>
<code>-r</code>参数指定go clean对于指定包的所有依赖进行go clean命令。<br/>
<code>-x</code>参数指定go clean在执行删除操作时将命令打印。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 通过http服务获取程序性能统计数据]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/01/08/golang-tong-guo-httpfu-wu-huo-qu-cheng-xu-xing-neng-tong-ji-shu-ju/"/>
    <updated>2017-01-08T22:55:07+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/01/08/golang-tong-guo-httpfu-wu-huo-qu-cheng-xu-xing-neng-tong-ji-shu-ju</id>
    <content type="html"><![CDATA[<p>Golang标准库<code>net/http/pprof</code>通过HTTP服务对外提供性能统计数据，以便<code>pprof</code>这样的可视化工具使用。</p>

<p>引入此<code>pprof</code>库向http服务注册路径处理函数。此库注册的http服务路径都是以<code>/debug/pprof</code>开头。</p>

<h2>使用方法</h2>

<h3>方式引入库</h3>

<pre><code>import _ "net/http/pprof"
</code></pre>

<h3>开启HTTP服务</h3>

<p>如果程序中已经运行了一个或者多个HTTP服务，那么就无需再开启HTTP服务，否则需要像如下代码片段，开启一个HTTP服务：</p>

<pre><code>go func() {
    log.Println(http.ListenAndServe("localhost:6060",   nil))
}()
</code></pre>

<p>其中地址也可以不绑定到localhost,可以选择监听所有端口,比如:</p>

<pre><code>go func() {
    log.Println(http.ListenAndServe(":6060",    nil))
}()
</code></pre>

<h3>获取性能数据</h3>

<p>1、查看堆栈性能数据</p>

<pre><code>go tool pprof http://localhost:6060/debug/pprof/heap
</code></pre>

<p>2、查看30s CPU性能数据</p>

<pre><code>go tool pprof http://localhost:6060/debug/pprof/profile
</code></pre>

<p>3、查看goroutine阻塞性能数据</p>

<pre><code>go tool pprof http://localhost:6060/debug/pprof/block
</code></pre>

<p>4、查看5s执行栈</p>

<pre><code>wget http://localhost:6060/debug/pprof/trace?seconds=5
</code></pre>

<p>5、查看所有可用性能数据</p>

<pre><code>浏览器打开  http://localhost:6060/debug/pprof/
</code></pre>

<p>参考：<br/>
<a href="https://golang.org/pkg/net/http/pprof/">Golang官博</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[golang创建、解压.tar.gz文件简单库]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/01/05/golangchuang-jian-,-jie-ya-dot-tar-dot-gzwen-jian/"/>
    <updated>2017-01-05T19:17:06+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/01/05/golangchuang-jian-,-jie-ya-dot-tar-dot-gzwen-jian</id>
    <content type="html"><![CDATA[<p>golang提供了<code>tar</code>包和<code>compress/gzip</code>包进行文件打包和压缩，但是没有函数同时进行打包和压缩，下面利用打包和压缩功能，实现一个简单的制作和解压.tar.gz文件的功能。</p>

<h2>tar打包功能</h2>

<p>利用tar中<code>Writer</code>和<code>Reader</code>可以实现将文件和文件夹进行打包的功能。</p>

<h3>打包</h3>

<p>创建目标文件</p>

<pre><code>f, err := os.Create(dstPath)
</code></pre>

<p>创建<code>Writer</code></p>

<pre><code>tw := tar.NewWriter(f)
</code></pre>

<p>循环遍历文件夹，写入Writer</p>

<pre><code>fileInfo, err := os.Stat(path)
if err != nil {
    return err
}
if fileInfo.Mode().IsRegular() {
    header, err := tar.FileInfoHeader(fileInfo, "")
    if err != nil {
        return err
    }
    header.Name = path
    if err = tw.WriteHeader(header); err != nil {
        return err
    }
    file, err := os.Open(path)
    if err != nil {
        return err
    }
    if _, err = io.Copy(tw, file); err != nil {
        return err
    }
}

if fileInfo.Mode().IsDir() {
    // tar each file and dir in the dir
    var file *os.File
    if file, err = os.Open(path); err != nil {
        return err
    }
    fileInfos, err := file.Readdir(0)
    if err != nil {
        return err
    }
    for _, info := range fileInfos {
        if err = tarPath(filepath.Join(path, info.Name()), tw); err != nil {
            return err
        }
    }
}
</code></pre>

<!-- more -->


<h3>解包</h3>

<p>打开源文件</p>

<pre><code>tarFile, err := os.Open(srcPath)
</code></pre>

<p>创建Reader</p>

<pre><code>tr := tar.NewReader(tarFile)
</code></pre>

<p>循环遍历解压文件</p>

<pre><code>for {
    hdr, err := tr.Next()
    if err == io.EOF {
        break
    }
    fullPath := filepath.Join(dstPath, hdr.Name)
    os.MkdirAll(filepath.Dir(fullPath), os.ModePerm)
    log.Println("fullPath", fullPath)
    file, err := os.Create(fullPath)
    if err != nil {
        return err
    }
    if _, err := io.Copy(file, tr); err != nil {
        return err
    }
    file.Close()
}
</code></pre>

<h2>Gzip压缩功能</h2>

<h3>压缩</h3>

<p>创建目标文件</p>

<pre><code>dstFile, err := os.Create(dstPath)
</code></pre>

<p>创建Writer</p>

<pre><code>gw := gzip.NewWriter(dstFile)
</code></pre>

<p>将源内容写入Writer</p>

<pre><code>if _, err = io.Copy(gw, srcFile); err != nil {
    return err
}
</code></pre>

<h3>解压</h3>

<p>打开源文件</p>

<pre><code>srcFile, err := os.Open(srcPath)
</code></pre>

<p>创建Reader</p>

<pre><code>gr, err := gzip.NewReader(srcFile)
</code></pre>

<p>进行解压</p>

<pre><code>if _, err = io.Copy(dstFile, gr); err != nil {
    return err
}
</code></pre>

<h2>.tar.gz文件</h2>

<p>将上面tar包进行打包和解包湿的的<code>io.Writer</code>和 <code>io.Reader</code>实参传入<code>gzip.Writer</code>和<code>gzip.Reader</code> ，即可将打包的目的文件进行压缩和解包时的源文件进行解压</p>

<h3>打包压缩</h3>

<pre><code>func Targz(srcPath, dstPath string) error {
dstFile, err := os.Create(dstPath)
if err != nil {
    return err
}
defer dstFile.Close()
gw := gzip.NewWriter(dstFile)
defer gw.Close()
tw := tar.NewWriter(gw)
defer tw.Close()
if err = tarPath(srcPath, tw); err != nil {
    dstFile.Close()
    os.Remove(dstPath)
    return err
}
return nil
</code></pre>

<p>}</p>

<h3>解压解包</h3>

<pre><code>srcFile, err := os.Open(srcPath)
if err != nil {
    return err
}
gr, err := gzip.NewReader(srcFile)
if err != nil {
    return err
}
tr := tar.NewReader(gr)
for {
    hdr, err := tr.Next()
    if err == io.EOF {
        break
    }
    fullPath := filepath.Join(dstPath, hdr.Name)
    os.MkdirAll(filepath.Dir(fullPath), os.ModePerm)
    file, err := os.Create(fullPath)
    if err != nil {
        return err
    }
    if _, err := io.Copy(file, tr); err != nil {
        return err
    }
    file.Close()
}
</code></pre>

<h3>备注</h3>

<p>完整源代码请参考<a href="https://github.com/jintao-zero/targz">targz</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[golang cpu性能优化]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/01/01/golang-cpuxing-neng-you-hua/"/>
    <updated>2017-01-01T17:18:20+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/01/01/golang-cpuxing-neng-you-hua</id>
    <content type="html"><![CDATA[<p>本文根据<a href="https://blog.golang.org/profiling-go-programs">Profiling Go Programs</a>文章，进行演示如何利用Golang性能工具进行cpu性能统计和优化。</p>

<h2>准备工作</h2>

<p>1、Golang编译运行环境。</p>

<pre><code>go version go1.7 darwin/amd64
</code></pre>

<p>2、下载<a href="https://storage.googleapis.com/google-code-archive-source/v2/code.google.com/benchgraffiti/source-archive.zip">测试源码</a></p>

<pre><code>-rw-r--r-- 1 jintao staff 16594  1  1 16:58 havlak1.go
-rw-r--r-- 1 jintao staff 16597  1  1 16:58 havlak2.go
-rw-r--r-- 1 jintao staff 16832  1  1 16:58 havlak3.go
-rw-r--r-- 1 jintao staff 16905  1  1 16:58 havlak4.go
-rw-r--r-- 1 jintao staff 17501  1  1 16:58 havlak5.go
-rw-r--r-- 1 jintao staff  9467  1  1 16:58 havlak6.go
</code></pre>

<p>havlak1-6是源文件，以及优化后的源文件</p>

<h2>采集CPU性能数据</h2>

<p>优化程序之前，需要采集性能数据。多种方法可以使用，本文中采用的方法是引入<code>runtime/pprof</code>包，在代码文件main函数中添加如下代码片段:</p>

<pre><code>var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

func main() {
    flag.Parse()
    if *cpuprofile != "" {
        f, err := os.Create(*cpuprofile)
        if err != nil {
          log.Fatal(err)
        }
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
    ... 
</code></pre>

<p>利用flag包设置并解析cpuprofile参数，传入文件名，创建文件，调用<code>ppfof.StartCPUProfile</code>方法开始进行采样，并将采样结果保存在文件中，在程序返回之前调用<code>pprof.StopCPUProfile</code>方法确保所有采样数据刷新到结果文件中。</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ time ./havlak1 -cpuprofile=havlak1.prof
# of loops: 76000 (including 1 artificial root node)

real    0m21.768s
user    0m31.026s
sys 0m0.284s
</code></pre>

<p>产生性能文件havlak1.prof</p>

<!-- more -->


<h2>分析性能文件</h2>

<p><code>go tool pprof</code>是<a href="https://code.google.com/p/gperftools/wiki/GooglePerformanceTools">Google&rsquo;s pprof C++ profiler</a>一个变种，利用go tool pprof命令读取分析性能文件:</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ go tool pprof havlak1 havlak1.prof
Entering interactive mode (type "help" for commands)
(pprof)
</code></pre>

<p>输入<code>help</code>可以查看哪些可用命令，最常用是<code>top n</code>命令，查看前n个样本：</p>

<pre><code>(pprof) top
18750ms of 27430ms total (68.36%)
Dropped 95 nodes (cum &lt;= 137.15ms)
Showing top 10 nodes out of 80 (cum &gt;= 790ms)
      flat  flat%   sum%        cum   cum%
    3360ms 12.25% 12.25%     6790ms 24.75%  runtime.scanobject
    2890ms 10.54% 22.79%    14430ms 52.61%  main.FindLoops
    2470ms  9.00% 31.79%     2760ms 10.06%  runtime.mapaccess1_fast64
    1950ms  7.11% 38.90%     5140ms 18.74%  runtime.mapassign1
    1690ms  6.16% 45.06%     4080ms 14.87%  runtime.mallocgc
    1630ms  5.94% 51.00%     1630ms  5.94%  runtime.heapBitsForObject
    1580ms  5.76% 56.76%     3440ms 12.54%  main.DFS
    1250ms  4.56% 61.32%     1250ms  4.56%  runtime.memmove
    1140ms  4.16% 65.48%     1890ms  6.89%  runtime.greyobject
     790ms  2.88% 68.36%      790ms  2.88%  runtime/internal/atomic.Or8
(pprof)
</code></pre>

<p>启动性能分析时，Go程序每秒钟停止100次并对当前正在执行的goroutine调用栈进行采样。从上面数据可以看到，程序总执行时间为27430ms，采样top10函数一共占用18750ms（68.36%）。每行是一个函数的统计数据，前两列数据分别为采样时goroutine正在当前函数中的时间和占比，后两列为采样时此函数出现（正在执行或正在等待调用函数返回）的时间和占比。sum%列为前n行消耗时间之和对于总时间的占比。<code>main.FindLoops</code>函数正在执行的时间是2890ms占10.54%，在调用栈中出现的时间为14430ms占比为52.61%。<code>runtime.mapaccess1_fast64</code>执行的时间为2470ms占9.00%，在调用栈中出现的时间为2760ms占比为10.06%。使用-cum参数，按照第四第五列排序</p>

<pre><code>(pprof) top5 -cum
2.89s of 27.43s total (10.54%)
Dropped 95 nodes (cum &lt;= 0.14s)
Showing top 5 nodes out of 80 (cum &gt;= 14.43s)
  flat  flat%   sum%        cum   cum%
     0     0%     0%     22.79s 83.08%  runtime.goexit
     0     0%     0%     14.52s 52.93%  main.main
     0     0%     0%     14.52s 52.93%  runtime.main
     0     0%     0%     14.43s 52.61%  main.FindHavlakLoops
 2.89s 10.54% 10.54%     14.43s 52.61%  main.FindLoops
(pprof)
</code></pre>

<p>调用栈采样数据中关于函数间的调用关系可以有其他的有趣方式进行展现。比如<code>web</code>命令输出一个图片并用浏览器打开。<code>gv</code>命令写PostScript并在Ghostview中打开。</p>

<pre><code>(pprof) web
(pprof)
</code></pre>

<p>以下为图片部分截图： <br/>
<img src="/images/havlak1.png" alt="web" />
    图中每个方块对应一个单独函数，方块的大小与函数消耗的时间相对应。从X到Y的边显示X调用Y；边上的数字代表在被调用函数中消耗的时间。从图中我们可以发现在runtime.mapaccess1_fast64和runtime.mapassign1函数上消耗了较多时间。<br/>
    可以只显示包含某个函数的调用关系图：</p>

<pre><code>(pprof) web mapaccess
(pprof)
</code></pre>

<p><img src="/images/havlak1-mapaccess.png" alt="mapaccess" /><br/>
从上图我们可以发现主要是main.DFS和main.FindLoops函数调用了runtime.mapaccess<br/>
接下来重点分析<code>main.DFS</code>和<code>main.FindLoops</code>两个函数的时间消耗情况：</p>

<pre><code>(pprof) list DFS
Total: 27.43s
ROUTINE ======================== main.DFS in /Users/jintao/Project/opensource/benchgraffiti/havlak_new/havlak1.go
     1.58s      6.84s (flat, cum) 24.94% of Total
         .          .    235:   return false
         .          .    236:}
         .          .    237:
         .          .    238:// DFS - Depth-First-Search and node numbering.
         .          .    239://
      20ms       20ms    240:func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int {
     140ms      140ms    241:   nodes[current].Init(currentNode, current)
         .      310ms    242:   number[currentNode] = current
         .          .    243:
         .          .    244:   lastid := current
        1s         1s    245:   for _, target := range currentNode.OutEdges {
     160ms      1.31s    246:       if number[target] == unvisited {
      40ms      3.44s    247:           lastid = DFS(target, nodes, number, last, lastid+1)
         .          .    248:       }
         .          .    249:   }
     200ms      600ms    250:   last[number[currentNode]] = lastid
      20ms       20ms    251:   return lastid
         .          .    252:}
         .          .    253:
         .          .    254:// FindLoops
         .          .    255://
         .          .    256:// Find loops and build loop forest using Havlak's algorithm, which
(pprof)
</code></pre>

<p><code>list DFS</code> 会列出所有匹配DFS函数名的函数。从上面的代码我们发现耗时的语句分别在<code>242 246 247 250</code>行其中 247行是与DFS行数调用有关，其他三行都是与number变量有关，number是一个map数据结构，可以考虑改为采用slice，使用block number作为索引。</p>

<p>对文件进行修改，diff修改如下：</p>

<pre><code>240c240
&lt; func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int {
---
&gt; func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number []int, last []int, current int) int {
242c242
&lt;   number[currentNode] = current
---
&gt;   number[currentNode.Name] = current
246c246
&lt;       if number[target] == unvisited {
---
&gt;       if number[target.Name] == unvisited {
250c250
&lt;   last[number[currentNode]] = lastid
---
&gt;   last[number[currentNode.Name]] = lastid
271c271
&lt;   number := make(map[*BasicBlock]int)
---
&gt;   number := make([]int, size)
287c287
&lt;       number[bb] = unvisited
---
&gt;       number[bb.Name] = unvisited
315c315
&lt;               v := number[nodeV]
---
&gt;               v := number[nodeV.Name]
</code></pre>

<p>测试修改后的cpu性能：</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ go build havlak2.go
MacBook-Pro-2:havlak_new jintao$ time ./havlak2 -   cpuprofile=havlak2.prof
# of loops: 76000 (including 1 artificial root node)

real    0m11.685s
user    0m19.647s
sys 0m0.268s
</code></pre>

<p>再次使用go tool profile工具查看topn数据：</p>

<pre><code>MacBook-Pro-2:havlak_new jintao$ go tool pprof havlak2 havlak2.prof
Entering interactive mode (type "help" for commands)
(pprof) top
11460ms of 16610ms total (68.99%)
Dropped 92 nodes (cum &lt;= 83.05ms)
Showing top 10 nodes out of 87 (cum &gt;= 540ms)
   flat  flat%   sum%        cum   cum%
2950ms 17.76% 17.76%     5630ms 33.90%  runtime.scanobject
1500ms  9.03% 26.79%     4100ms 24.68%  runtime.mallocgc
1260ms  7.59% 34.38%     1260ms  7.59%  runtime.heapBitsForObject
1250ms  7.53% 41.90%     8700ms 52.38%  main.FindLoops
 920ms  5.54% 47.44%     1450ms  8.73%  runtime.greyobject
 920ms  5.54% 52.98%     2120ms 12.76%  runtime.mapassign1
 770ms  4.64% 57.62%      780ms  4.70%  runtime.heapBitsSetType
 760ms  4.58% 62.19%      760ms  4.58%  runtime.memmove
 590ms  3.55% 65.74%     1500ms  9.03%  runtime.makemap
 540ms  3.25% 68.99%      540ms  3.25%  runtime/internal/atomic.Or8
(pprof)
</code></pre>

<p>从上面可以看到<code>main.DFS</code>已经不在topn列表上，其他函数的时间也在显著下降。现在累计有24.68%的时间用在分配内存和垃圾回收（<code>runtime.mallocgc</code>）。下面需要使用进行内存性能优化。</p>

<h2>参考</h2>

<p>1、<a href="https://blog.golang.org/profiling-go-programs">Golang官方博客</a><br/>
2、<a href="https://code.google.com/p/gperftools/wiki/GooglePerformanceTools">C++ pprof</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang日期转化处理]]></title>
    <link href="http://jintao-zero.github.io/blog/2016/10/30/golangri-qi-zhuan-hua-chu-li/"/>
    <updated>2016-10-30T22:13:12+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2016/10/30/golangri-qi-zhuan-hua-chu-li</id>
    <content type="html"><![CDATA[<p>golang中time包提供了时间操作函数。</p>

<h2>获取时间</h2>

<pre><code>type Time struct {
    // contains filtered or unexported fields
}

func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time
func Now() Time
</code></pre>

<p>一个Time结构体代表一个纳米精度的时间实例。now函数可以获取当前时间：</p>

<pre><code>now := time.Now()
fmt.Println(now)
</code></pre>

<p>结果如下：</p>

<pre><code>2016-11-27 22:46:17.666418725 +0800 CST 
</code></pre>

<!-- more -->


<h2>格式化时间</h2>

<pre><code>func (t Time) Format(layout string) string
</code></pre>

<p>Format方法可以按照layout定义的格式格式化时间字符串。<br/>
Golang中以2006 01 02 03 04 05 分别定义年、月、日 时、分、秒字段，03的24表示法为15。<br/>
比如将当前时间格式化为YYYY-mm-dd hh:MM:ss，则layout为<code>2006-01-02 15:04:05</code></p>

<pre><code>now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))
</code></pre>

<p> 输出为：</p>

<pre><code>2016-11-27 22:56:40
</code></pre>

<p>控制精度的方法为在秒后面加0, 000、000000、000000000分别代表毫秒、微秒、纳秒：</p>

<pre><code>now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))
fmt.Println(now.Format("2006-01-02 15:04:05.000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000000"))
</code></pre>

<p>输出：</p>

<pre><code>now := time.Now()
fmt.Println(now.Format("2006-01-02 15:04:05"))
fmt.Println(now.Format("2006-01-02 15:04:05.000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000"))
fmt.Println(now.Format("2006-01-02 15:04:05.000000000"))
</code></pre>

<h2>解析时间</h2>

<pre><code>func Parse(layout, value string) (Time, error)
func ParseInLocation(layout, value string, loc *Location) (Time, error)
</code></pre>

<p>Parse函数将格式化字符串解析为一个时间实例。<code>layout</code>定义了时间字符串的表现格式，比如：</p>

<pre><code>Mon Jan 2 15:04:05 -0700 MST 2006
</code></pre>

<p>当待解析时间字符串中没有时区时，<code>Parse</code>默认按照<code>UTC</code>时区解析时间。<code>ParseInLocation</code>按照loc参数指定的的location解析时间。</p>

<h2>定时器</h2>

<p>定时器通过<code>NewTimer</code>或者<code>AfterFunc</code>创建，用AfterFunc创建的定时器超时后，在定时器goroutine中调用func函数，其他定时器则通过C通道发送一个时间对象。</p>

<pre><code>type Timer struct {
    C &lt;-chan Time
    // contains filtered or unexported fields
}

func AfterFunc(d Duration, f func()) *Timer  
func NewTimer(d Duration) *Timer
</code></pre>

<p>定时器在使用过程中需要注意<code>Reset</code>和<code>Stop</code>方法的使用：</p>

<pre><code>func (t *Timer) Stop() bool
</code></pre>

<p>Stop方法用来停止定时器触发。停止定时器则返回true，如果定时器已经超时或者已经被停止则返回false。Stop方法不关闭定时器中的channel。<br/>
为了防止调用Stop方法后，定时器仍然触发，需要检查方法返回值并且读取定时器时间channel，代码片段：</p>

<pre><code>if !t.Stop() {
    &lt;-t.C
}

func (t *Timer) Reset(d Duration) bool
</code></pre>

<p><strong>需要特别注意的是，不要并发执行上面的代码。</strong></p>

<p>Reset修改定时器的超时时间为d。修改成功则返回true，如果定时器已经超时或者被停止则返回false。</p>

<pre><code>func (t *Timer) Reset(d Duration) bool
</code></pre>

<p>为了重复一个已经激活的定时器，需要先调用定时器<code>Stop</code>方法，如果定时器已经超时，则例如一下代码片段，先读取channel中的时间：</p>

<pre><code>if !t.Stop() {
    &lt;-t.C
}
t.Reset(d)
</code></pre>

<p><strong>需要特别注意的是，不要并发执行上面的代码。</strong>  <br/>
在读取通道和定时器超时之间存在竞态条件，所以几乎不可能正确使用Reset方法的返回值。Reset方法应该总是与Stop方法一起使用。</p>
]]></content>
  </entry>
  
</feed>
