<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: golang | jintao's blog]]></title>
  <link href="http://jintao-zero.github.io/blog/tags/golang/atom.xml" rel="self"/>
  <link href="http://jintao-zero.github.io/"/>
  <updated>2017-08-09T16:32:18+08:00</updated>
  <id>http://jintao-zero.github.io/</id>
  <author>
    <name><![CDATA[jintao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[golang加两遍读锁导致程序死锁问题分析]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/06/20/golangjia-liang-bian-du-suo-dao-zhi-cheng-xu-si-suo-wen-ti-ji-lu/"/>
    <updated>2017-06-20T21:42:04+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/06/20/golangjia-liang-bian-du-suo-dao-zhi-cheng-xu-si-suo-wen-ti-ji-lu</id>
    <content type="html"><![CDATA[<p>golang程序使用读写锁对共享数据进行互斥保护时，注意在同一程序调用栈不要对锁进行多次加锁，这样会导致程序死锁，如下的代码片段就会导致程序死锁：</p>

<pre><code>import (
"sync"
"fmt"
"time"
_ "net/http/pprof"
"net/http"
)

var mutex sync.RWMutex

func f()  {
    fmt.Println("f begin to get Rlock ")
    mutex.RLock()
    defer mutex.RUnlock()
    fmt.Println("f get Rlock suc")
}

func main() {
    mutex.RLock()
    fmt.Println("main get RLock suc")
    defer mutex.RUnlock()

    go http.ListenAndServe(":6060", nil)
    go func() {
        fmt.Println("other goroutine begin to get write lock")
        mutex.Lock()
        defer mutex.Unlock()
        fmt.Println("other goroutine get write lock suc“)
    }()
    time.Sleep(time.Second)
    f()
}
</code></pre>

<p>程序执行结果如下：</p>

<pre><code>MacBook-Pro-2:sync jintao$ go run main.go 
main get RLock suc
other goroutine begin to get write lock
f begin to get Rlock
</code></pre>

<!-- more -->


<p>通过pprof工具查看相关goroutine调用栈：<br/>
main goroutine阻塞在获取读锁的位置：</p>

<pre><code>1 @ 0x102dfca 0x102e0ae 0x103e5a1 0x103e1a4 0x1060869 0x13119c6 0x1311bd7 0x102db7a 0x1059c01
#   0x103e1a3   sync.runtime_Semacquire+0x33    /usr/local/go/src/runtime/sema.go:47
#   0x1060868   sync.(*RWMutex).RLock+0x48  /usr/local/go/src/sync/rwmutex.go:43
#   0x13119c5   main.f+0xa5         /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:15
#   0x1311bd6   main.main+0x136         /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:33
#   0x102db79   runtime.main+0x209      /usr/local/go/src/runtime/proc.go:185
</code></pre>

<p>子goroutine阻塞在获取写锁的位置：</p>

<pre><code>1 @ 0x102dfca 0x102e0ae 0x103e5a1 0x103e1a4 0x106098e 0x1311cb6 0x1059c01
#   0x103e1a3   sync.runtime_Semacquire+0x33    /usr/local/go/src/runtime/sema.go:47
#   0x106098d   sync.(*RWMutex).Lock+0x6d   /usr/local/go/src/sync/rwmutex.go:91
#   0x1311cb5   main.main.func1+0xa5        /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:28
</code></pre>

<p>通过上面的调用栈，我们发现main goroutine在第21行已经获取了读锁，当在调用的函数<code>f</code>第15行再次尝试获取读锁时，程序阻塞。创建的goroutine在第28行尝试获取写所时，协程阻塞。</p>

<h2>分析</h2>

<p>这个是读写锁的一个标准行为。在
<a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Wikipedia &ldquo;Readers–writer lock&rdquo;</a>词条中对读写锁进行了介绍，在<code>Priority policies</code>一节中对<code>reader</code>和<code>writer</code>加锁时的优先级策略进行了说明，不同的优先级策略会给并发和死锁带来不同的影响：</p>

<ul>
<li>读优先策略 <br/>
  读优先允许最大并发，但是如果读并发太多，可能导致写饥饿。<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwji0rOAh9bUAhUW12MKHYx9CvUQFggyMAI&amp;url=http%3A%2F%2Fwww.beck-shop.de%2Ffachbuch%2Fleseprobe%2F9783642320262_Excerpt_001.pdf&amp;usg=AFQjCNEskoEL2n3HKpHGYVWc_XpU4z90nw">Concurrent Programming: Algorithms, Principles, and Foundations</a></li>
<li>写优先策略<br/>
  写优先策略可以避免上面读优先导致的写锁饥饿问题，如果有一个写锁着在等待，系统将会组织任何新reader加读锁成功，一旦当前已经获取的读锁释放完后，即会成功获取写锁。写优先策略相比较与读优先策略，会降低系统的并发性能。相对于读优先策略，写优先策略在实现上的效率要低，因为在获取或者释放读锁或者写锁时，都要操作多个互斥锁。</li>
<li>不指定优先级策略
  这种策略在一定场景下的效率更高</li>
</ul>


<p>从上面Wikipedia关于读写锁的说明看，golang中关于读写锁使用的是写优先策略，下面查看源码，对源码进行分析</p>

<h2>源码解析</h2>

<p>读写锁实现在sync/rwmutex.go文件中</p>

<pre><code>type RWMutex struct {
    w           Mutex  // 获取写锁时，必须获取的互斥量
    writerSem   uint32 // 写锁信号量
    readerSem   uint32 // 读锁信号量
    readerCount int32  // 目前获取的读锁个数
    readerWait  int32  // 需要等待reader释放锁个数
}
</code></pre>

<p><code>加载读锁：</code></p>

<pre><code>// RLock locks rw for reading.
func (rw *RWMutex) RLock() {
    if race.Enabled {
        _ = rw.w.state
        race.Disable()
    }
    if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 {
        // A writer is pending, wait for it.
        runtime_Semacquire(&amp;rw.readerSem)
    }
    if race.Enabled {
        race.Enable()
        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))
    }
}
</code></pre>

<p>每次获取读锁时，都对readerCount计数器进行加1，如果加1后值为负，那么说明有人正在获取写锁。等待readerSem信号量变为正</p>

<p><code>释放读锁：</code></p>

<pre><code>func (rw *RWMutex) RUnlock() {
    if race.Enabled {
        _ = rw.w.state
        race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))
        race.Disable()
    }
    if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 {
        if r+1 == 0 || r+1 == -rwmutexMaxReaders {
            race.Enable()
            panic("sync: RUnlock of unlocked RWMutex")
        }
        // A writer is pending.
        if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 {
            // The last reader unblocks the writer.
            runtime_Semrelease(&amp;rw.writerSem)
        }
    }
    if race.Enabled {
        race.Enable()
    }
}
</code></pre>

<p>释放写锁时，对readerCount减1，说明获取释放一个读锁，如果最新值为负，那么说明有人正在尝试获取写锁，readerWait记录了写锁需要等待的读锁个数，此时将readerWait个数减1，如果个素减为0，说明写锁正在等待的所有reader都已经释放读锁，此时可以释放写锁信号量，让程序获取写锁。</p>

<p><code>获取写锁：</code></p>

<pre><code>func (rw *RWMutex) Lock() {
    if race.Enabled {
        _ = rw.w.state
        race.Disable()
    }
    // First, resolve competition with other writers.
    rw.w.Lock()
    // Announce to readers there is a pending writer.
    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    // Wait for active readers.
    if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 {
        runtime_Semacquire(&amp;rw.writerSem)
    }
    if race.Enabled {
        race.Enable()
        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))
        race.Acquire(unsafe.Pointer(&amp;rw.writerSem))
    }
}
</code></pre>

<p>获取写锁时，首先获取互斥锁，这样其他写锁必须等待。然后设置读锁个数为负值，这样后面的reader就无法获取到读锁。如果读锁没有释放，则等待写锁信号量变为正。</p>

<p><code>释放写锁：</code></p>

<pre><code>func (rw *RWMutex) Unlock() {
    if race.Enabled {
        _ = rw.w.state
        race.Release(unsafe.Pointer(&amp;rw.readerSem))
        race.Release(unsafe.Pointer(&amp;rw.writerSem))
        race.Disable()
    }

    // Announce to readers there is no active writer.
    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)
    if r &gt;= rwmutexMaxReaders {
        race.Enable()
        panic("sync: Unlock of unlocked RWMutex")
    }
    // Unblock blocked readers, if any.
    for i := 0; i &lt; int(r); i++ {
        runtime_Semrelease(&amp;rw.readerSem)
    }
    // Allow other writers to proceed.
    rw.w.Unlock()
    if race.Enabled {
        race.Enable()
    }
}
</code></pre>

<p>释放写锁时，将等待获取读锁的个数变为实际值，根据等待获取读锁的个数，释放读锁信号量。</p>

<h2>结论</h2>

<p>根据上面对读写锁源码的分析，我们可以看到golang中读写锁是使用写锁优先策略的，博文开头的例子中，main主协程在已经获取读锁的情况，又尝试第二次获取读锁，因为已经创建了一个子协程在获取写锁，那么第二次获取读锁操作将被阻塞，这样就导致主协程无法释放第一次获取的读锁，从而子协程获取写锁失败，这样整个程序两个写成处于死锁状态。</p>

<h2>参考</h2>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/4sx5pPp8gFw">Lock re-accquision in sync forbiden</a></li>
<li><a href="https://golang.org/pkg/sync/#RWMutex.Lock">Package sync</a></li>
<li><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Readers–writer lock</a></li>
<li><a href="https://stackoverflow.com/questions/30547916/goroutine-blocks-when-calling-rwmutex-rlock-twice-after-an-rwmutex-unlock">goroutine blocks when calling RWMutex RLock twice after an RWMutex Unlock</a></li>
<li><a href="https://github.com/golang/go/issues/15418">sync: document that double RLock isn&rsquo;t safe #15418</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[golang 工程代码结构]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/06/11/golang-gong-cheng-dai-ma-jie-gou/"/>
    <updated>2017-06-11T12:19:45+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/06/11/golang-gong-cheng-dai-ma-jie-gou</id>
    <content type="html"><![CDATA[<p>golang工程常用代码目录结构</p>

<pre><code>github.com/user/project
    pkg
        p1
            *.go
        p2
            *.go 
    cmd
        cmdline
            main.go
    web
            main.go
    vendor
        github/*/*
    examples
    docs
</code></pre>

<h2>参考</h2>

<ul>
<li><p><a href="https://stackoverflow.com/questions/32634837/project-structure-for-a-tool-with-multiple-uis/32635264#32635264">Project structure for a tool with multiple UIs</a></p></li>
<li><p><a href="https://forum.golangbridge.org/t/how-should-i-structure-packages-for-a-multiple-binary-web-application/665">How should I structure packages for a multiple-binary web application?</a></p></li>
<li><a href="https://github.com/seccom/kpass">kpass</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
