<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[jintao's blog]]></title>
  <link href="http://jintao-zero.github.io/atom.xml" rel="self"/>
  <link href="http://jintao-zero.github.io/"/>
  <updated>2017-11-15T16:53:45+08:00</updated>
  <id>http://jintao-zero.github.io/</id>
  <author>
    <name><![CDATA[jintao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设置TCP连接keepalive保活]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/11/15/she-zhi-tcplian-jie-keepalivebao-huo/"/>
    <updated>2017-11-15T15:46:35+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/11/15/she-zhi-tcplian-jie-keepalivebao-huo</id>
    <content type="html"><![CDATA[<p>一个tcp连接包含两端。如何确保连接两端的socket都在线呢，一个方法是应用程序定期发送一个心跳信息给对方，tcp/ip提供了一个系统层面的保活机制，设置了socket keepalive属性后，系统会定期给对端发送心跳报文，根据是否能收到回复来判断对端是否在线，当对端不在线时，对本段socket的读操作将会读到EOF。</p>

<h2>keepalive</h2>

<p>三个属性决定keepalive如何工作，在Linux系统中，这三个属性位于<code>proc</code>文件系统中：</p>

<ul>
<li><code>tcp_keepalive_time</code><br/>
连接空闲时间，超时后发送保活探测包，默认为<code>7200</code>秒</li>
<li><code>tcp_keepalive_intvl</code><br/>
每天探测包之间的间隔时间，默认为：<code>75</code>秒</li>
<li><code>tcp_keepalive_probes</code>
总的保护包数，超过则认为对端不在线，默认为<code>9</code>个</li>
</ul>


<p>keepalvie的工作过程如下：</p>

<ol>
<li>客户端建立到服务端的连接</li>
<li>当连接的空闲时间超过<code>tcp_keepalive_time</code>时，客户端向服务端发送一个tcp<code>ACK</code>包</li>
<li>服务端是否对刚刚的<code>ACK</code>包进行回复？

<ul>
<li>NO

<ol>
<li>. 等待<code>tcp_keepalive_intvl</code>超时，发送<code>ACK</code>包</li>
<li>. 如果探测包个数达到<code>tcp_keepalive_probes</code>，则发送一个<code>RST</code>报文并关闭连接</li>
</ol>
</li>
<li>YES<br/>
   收到心跳包回复，则继续步骤2</li>
</ul>
</li>
</ol>


<p>大多数系统中，默认是开启tcp连接保活的，当对端(7200+74*9)秒都没有回复的话，则会关闭本端连接。</p>

<!-- more -->


<h2>修改具体连接保活属性</h2>

<p>系统提供了默认值，在具体应用程序中，我们可以单独对连接设置不同的属性值：<br/>
C/C++代码示例如下：</p>

<pre><code>int keepalive_enabled = 1;
int keepalive_idle = 10; // 10 second
int keepalive_intvl = 5; // send keepalive every 5 second
int keepalive_cnt = 3; //
int ret = setsockopt(conn_sock, SOL_SOCKET, SO_KEEPALIVE, &amp;keepalive_enabled, sizeof(int));
ret = setsockopt(conn_sock, IPPROTO_TCP, TCP_KEEPIDLE, &amp;keepalive_idle, sizeof(int));
ret = setsockopt(conn_sock, IPPROTO_TCP, TCP_KEEPINTVL, &amp;keepalive_intvl, sizeof(int));     
ret = setsockopt(conn_sock, IPPROTO_TCP, TCP_KEEPCNT, &amp;keepalive_cnt, sizeof(int));
</code></pre>

<h2>修改系统全局保活属性</h2>

<ul>
<li><p>修改proc文件系统中的属性值</p>

<pre><code>  echo 10 &gt; /proc/sys/net/ipv4/tcp_keepalive_time
  echo 5  &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl
  echo 3  &gt; /proc/sys/net/ipv4/tcp_keepalive_probes  
</code></pre>

<p>  这种方法修改的属性值，系统重启后属性值会恢复</p></li>
<li><p>sysctl命令修改</p>

<pre><code>  /sbin/sysctl -w net.ipv4.tcp_keepalive_time=10
  /sbin/sysctl -w net.ipv4.tcp_keepalive_intvl=5
  /sbin/sysctl -w net.ipv4.tcp_keepalive_probes=3
</code></pre>

<p>  这种方法，系统重启后属性值会恢复</p></li>
<li><p>修改/etc/sysctl.conf配置文件</p>

<pre><code>  net.ipv4.tcp_keepalive_time=10
  net.ipv4.tcp_keepalive_intvl=5
  net.ipv4.tcp_keepalive_probes=3   
</code></pre></li>
</ul>


<p> ##参考
* <a href="http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html">Custom Configuration of TCP Socket Keep-Alive Timeouts</a><br/>
* <a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html">TCP Keepalive HOWTO</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用logroate管理日志文件]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/11/11/shi-yong-logroateguan-li-ri-zhi-wen-jian/"/>
    <updated>2017-11-11T11:15:06+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/11/11/shi-yong-logroateguan-li-ri-zhi-wen-jian</id>
    <content type="html"><![CDATA[<p>logrotate命令设计用来管理日志文件。它可以自动循环，压缩，删除和邮件发送日志文件。可以根据不同的周期（日、周、月）和大小来管理文件。<br/>
通常情况下，logrotate作为cron天任务每天执行一次。如果logrotate一天之中被运行了多次，除非设置size作为日志循环处理条件或者使用<code>-f</code>或者<code>--force</code>参数，否则日志文件不会被多次处理。</p>

<h2>logrotate如何工作</h2>

<p>系统以通常是每天cron任务运行logrotate。CentOS系统中<code>logrotate</code>定时任务脚本位于<code>/etc/cron.daily</code>中。<br/>
如果以更高的频率运行logrotate任务，那么可以将<code>logrotate</code>放置在<code>/etc/cron.hourly</code>目录中。<br/>
logrotate运行时会读取/etc/logrotate.conf文件中的配置，根据文件中配置的信息对日志文件进行处理。<br/>
logrotate cron任务执行脚本如下：</p>

<pre><code>#!/bin/sh

/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf
EXITVALUE=$?
if [ $EXITVALUE != 0 ]; then
    /usr/bin/logger -t logrotate "ALERT exited abnormally with [$EXITVALUE]"
fi
exit 0
</code></pre>

<!-- more -->


<h2>logrotate.conf</h2>

<p>logrotate主要的配置文件是<code>/etc/logrotate.conf</code>。<br/>
这个配置文件中包含了一些logrotate在执行日志处理时的默认配置。<br/>
在这个文件中包含了其他的配置文件：</p>

<pre><code># RPM packages drop log rotation information into this directory
include /etc/logrotate.d
</code></pre>

<p>我们可以将应用相关配置文件放置在<code>/etc/logrotate.d/</code>目录下</p>

<h2>logrotate.d</h2>

<p><code>ls /etc/logrotate.d/</code>可以查看系统中已经配置的应用相关配置文件：</p>

<pre><code>[root@test logrotate.d]# ls -al /etc/logrotate.d/
total 40
drwxr-xr-x.  2 root root  4096 Nov 11 09:57 .
drwxr-xr-x. 89 root root 12288 Nov 10 14:15 ..
-rw-r--r--   1 root root   243 Oct 31  2016 nginx
-rw-r--r--.  1 root root   136 Jun 10  2014 ppp
-rw-r--r--   1 root root   127 Aug  5  2016 redis
-rw-r--r--   1 root root   224 Nov  5  2016 syslog
-rw-r--r--   1 root root   100 Mar  3  2017 wpa_supplicant
-rw-r--r--   1 root root   100 Nov 15  2016 yum
[root@test logrotate.d]#
</code></pre>

<p>配置文件中配置了关于如何对应用产生的日志文件进行处理的配置信息：</p>

<pre><code>[root@test logrotate.d]# cat nginx
    /var/log/nginx/*log {
    create 0644 nginx nginx
    daily
    rotate 10
    missingok
    notifempty
    compress
    sharedscripts
    postrotate
        /bin/kill -USR1 `cat /run/nginx.pid 2&gt;/dev/null` 2&gt;/dev/null || true
    endscript
}
</code></pre>

<p>下面会对配置文件中的配置命令进行详细说明。</p>

<h2>配置命令</h2>

<p>可以使用通过查看man手册获取logrotate命令的相信命令参数说明：</p>

<pre><code>man logrotate
</code></pre>

<p>/etc/logrotate.conf中配置了默认设置，应用配置文件会继承并覆盖/etc/logrotate.conf中的配置方法。</p>

<h3>Log files</h3>

<p>在上面nginx相关的配置信息中，开头的<code>/var/log/nginx/*log</code>即定义了需要处理的日志文件路径，大括号中的配置命令是对日志文件进行的具体配置。 <br/>
配置日志文件路径时，可以使用通配符。在一个文件中可以包含多个这样的配置信息。</p>

<h3>Rotate Count</h3>

<p><code>rotate</code>命令配置了旧日志文件保留个数。当保留的日志文件超过这个数目时，最老的日志文件将会被删除。</p>

<pre><code>rotate 10
</code></pre>

<p>这个命令高速logrotate保留10个日志文件。</p>

<h3>Rotation interval</h3>

<p>可以通过以下命令设置日志文件处理周期：</p>

<pre><code>daily
weekly
monthly
yearly
</code></pre>

<p>如果配置中没有指定时间周期，每次logrotate运行时都会日志文件进行处理，除非配置了size信息。<br/>
如果想以不同的周期运行logrotate工具，可以设置不同的cron任务。比如，每小时执行一次logrotate工具，可以在<code>/etc/cron.hourly</code>中放置执行脚本，包含以下执行命令：</p>

<pre><code>/usr/sbin/logrotate /etc/logrotate.hourly.conf
</code></pre>

<p>在<code>/etc/logrotate.hourly.conf</code>配置文件包含需要每小时进行处理的日志配置信息。</p>

<h3>Size</h3>

<p>可以使用<code>size</code>命令配置一个文件大小，logrotate工具根据这个文件大小来判断是否对日志文件进行处理。</p>

<pre><code>size 100k
size 100M
size 100G
</code></pre>

<p>第一个命令配置日志文件大于100k字节时处理文件，第二个命令配置日志文件大于100M字节时处理日志文件，第三个命令配置日志文件大于100G时处理日志文件。 通常情况不建议将size设置太大。</p>

<p>需要注意的是，<code>size</code>命令与<code>时间周期</code>配置是互斥的，根据试验表明，后面设置的数据行会覆盖前面, 当后面配置了<code>size</code>时，前面配置的<code>时间周期</code>将不起作用，反之亦然。</p>

<h3>Compression</h3>

<p>如果希望对产生的旧日志文件进行压缩处理，通常可以在<code>/etc/logrotate.conf</code>中配置<code>compress</code>，如果作为全局配置，那么所有产生的日志文件都会被压缩（以gzip格式）：</p>

<pre><code>compress
</code></pre>

<p>对于具体应用来说，如果不想对日志文件进行压缩处理，那么可以使用<code>nocompress</code>进行配置：</p>

<pre><code>nocompress
</code></pre>

<h3>Postrotate</h3>

<p>logrotate每次处理配置文件配置的日志文件后将会运行<code>postrotate</code>脚本。通常使用<code>postrotate</code>脚本在处理日志文件后重启应用，这样应用可以使用一个新日志文件。</p>

<pre><code>postrotate
    /usr/sbin/apachectl restart &gt; /dev/null
endscript
</code></pre>

<p><code>postrotate</code>命令表示脚本开始，<code>endscript</code>命令表示脚本结束。</p>

<h3>sharedscripts</h3>

<p><code>sharescripts</code>告诉logrotate只运行一次<code>postrotate</code>脚本。</p>

<p>下面的脚本示例：</p>

<pre><code>/data/l1/ss/test/trend/log.txt {
    rotate 5            # 保存5个旧日志文件
    copytruncate        # 拷贝并清除日志文件
    #size 20M
    maxsize 20M     # 日志文件最大大小为20M，达到20M时即被清理
    start 0         # 日志文件从0编号
    weekly              # 每周清理一次
    #dateext
    #dateyesterday
    createolddir       # 如果日志文件保存路径不存在，则创建
    olddir /data/l1/ss/test/trend/log      # 旧日志文件保存路径
}
</code></pre>

<h2>测试 logrotate</h2>

<p>如果怀疑日志文件没有被正确处理，或者添加了一个新配置，可以使用一些参数对logrotate进行调试。</p>

<h3>Verbose</h3>

<p><code>-v</code>参数，告诉logrotate输出详细信息。当logrotate没有按照设想处理日志时，使用<code>-v</code>参数进行调试。</p>

<h3>Ddbug</h3>

<p><code>-d</code>参数，告诉logrotate去检查日志文件，但是不实际执行处理动作。在测试新配置文件时，这个参数很有作用。<br/>
debug参数可以帮助检查配置文件格式是否正确和是否能够发现日志文件。</p>

<h3>Force</h3>

<p><code>-f</code>参数，强制logrotate工具处理所有日志文件，不管当时日志文件是否满足处理条件。</p>

<h3>Combining flags</h3>

<p>测试命令可以组合使用。让logrotate强制执行并且输出所有详细信息，但是不实际执行，可以使用如下命令：</p>

<pre><code>/usr/sbin/logrotate -vdf /etc/logrotate.conf
</code></pre>

<p>我们将会看到它会列出logrotate将会做什么，包括哪些日志文件将会处理和处理过程。</p>

<p>如果想测试所有的配置信息，可以强制执行：</p>

<pre><code>/usr/sbin/logrotate -vf /etc/logrotate.conf
</code></pre>

<p>日志将会强制处理，并打印详细信息。</p>

<h2>状态信息</h2>

<p>查看logrotate状态信息：</p>

<pre><code>cat /var/lib/logrotate.status
logrotate state -- version 2
"/var/log/acpid.log" 2010-6-18
"/var/log/iptables.log" 2010-6-18
"/var/log/uucp.log" 2010-6-29
..
</code></pre>

<h2>参考</h2>

<ul>
<li>man logrotate</li>
<li><a href="https://support.rackspace.com/how-to/understanding-logrotate-utility/">Understanding logrotate utility</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Context包源码分析]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/10/26/go-contextbao-yuan-ma-fen-xi/"/>
    <updated>2017-10-26T10:38:30+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/10/26/go-contextbao-yuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<p>Go标准库<code>context</code>定义了一个<code>Context</code>类型，Context类型包含超时时间，取消信号和请求范围内的变量值。<br/>
context包提供了<code>WithCancel</code>，<code>WithDeadline</code>和<code>WithTimeout</code>函数来分别返回不同类型的Context接口。  <br/>
下面对context包的源码进行分析：</p>

<ul>
<li><a href="#Context">Context接口</a></li>
<li><a href="#emptyCtx">空Context接口对象</a></li>
<li><a href="#cancelCtx">cancelCtx</a></li>
<li><a href="#WithDealine">WithDeadline</a></li>
<li><a href="#WithValue">WithValue</a></li>
</ul>


<!-- more -->


<h2><span id="Context">Context接口</span></h2>

<pre><code>type Context interface {
    // Dealine 返回任务完成的最后期限时间，如果没有设置Deadline，则ok返回false。
    Deadline() (deadline time.Time, ok bool)

    // Done返回一个channel，当这个Conetext代表的任务应该取消时，这个channel将会被关闭。如果这个context不应该被取消，那么Done返回nil。
    Done() &lt;- chan struct{}

    // 如果Done返回的channel没有被关闭，Err返回nil。
    // 如果Done返回的channel被关闭了，Err返回一个非nil error表示原因：Canceled表示被取消，DeadlineExceeded表示达到超时时间
    Err() error

    // Value返回context中key对应的值。如果没有key对应的值则返回nil
    Value(key interface{}) interface{}
}   
</code></pre>

<h2><span id="emptyCtx">空Context接口对象</span></h2>

<p>context包提供了两个函数<code>TODO</code>和<code>Background</code>来返回一个非nil、空Context对象。</p>

<pre><code>var (
    background = new(emptyCtx)
    todo       = new(emptyCtx)
)
func Background() Context {
    return background   
}
func TODO() Context {
    return todo
}
</code></pre>

<p><code>emptyCtx</code>类型定义如下：</p>

<pre><code>// 一个emptyCtx类型Context不可以取消，没有值，没有超时时间。它不是一个空struct{}类型，因为我们需要不同类型的emptyCtx变量拥有不同地址。  
type emptyCtx int
</code></pre>

<p>   // 下面是实现的Context接口方法
    func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
        return
    }</p>

<pre><code>func (*emptyCtx) Done() &lt;-chan struct{} {
    return nil
}

func (*emptyCtx) Err() error {
    return nil
}

func (*emptyCtx) Value(key interface{}) interface{} {
    return nil
}

func (e *emptyCtx) String() string {
    switch e {
        case background:
            return "context.Background"
        case todo:
            return "context.TODO"
    }
    return "unknown empty Context"
}
</code></pre>

<h2><span id="cancelCtx">cancelCtx</span></h2>

<p>使用<code>WithCancel</code>创建可取消Context接口</p>

<pre><code>// WithCancel返回一个新Context接口对象和一个CancelFunc函数，当parent对象Donechannel激活或者调用CancelFunc函数时，新产生的Context对象Done返回的channel通道被激活
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    c := newCancelCtx(parent)
    propagateCancel(parent, &amp;c)
    return &amp;c, func() { c.cancel(true, Canceled) }
}

// newCancelCtx 返回一个初始化的cancelCtx对象.
func newCancelCtx(parent Context) cancelCtx {
    return cancelCtx{
        Context: parent,
        done:    make(chan struct{}),
    }
}


// cancelCtx可以被取消. 当cancelCtx被取消时，它同时也会取消孩子中那些实现了canceler接口的孩子
type cancelCtx struct {
    Context
    done chan struct{} // 调用取消函数时，通道被关闭

    mu       sync.Mutex
    children map[canceler]struct{} // 第一次调用cancel函数时，children设置为nil
    err      error                 // 调用cancel函数时，设置为非空
}
</code></pre>

<p>propagateCancel方法用来向父Context添加一个canceler孩子，这样当父对象结束时，同时会将孩子结束。</p>

<pre><code>func propagateCancel(parent Context, child canceler) {
    if parent.Done() == nil {
        return // 如果parent的Done为空，则parent不可以取消，比如默认的context.BackGround和context.TODO返回的接口对象
    }
    // 使用parentCancelCtx查找context链上的父cancelContext对象
    if p, ok := parentCancelCtx(parent); ok {
        p.mu.Lock()
        if p.err != nil {
            // 父对象已经被取消，那么也就没有必要再向父对象添加，此时取消子对象
            child.cancel(false, p.err)
        } else {
            // 向父对象中添加子对象
            if p.children == nil {
                p.children = make(map[canceler]struct{})
            }
            p.children[child] = struct{}{}
        }
        p.mu.Unlock()
    } else {
    // 如果父对象不是可取消对象，那么新建goroutine等待父对象结束后，取消子对象，在目前已知的集中Context接口实现，好像不能走到此流程
        go func() {
            select {
            case &lt;-parent.Done():
                child.cancel(false, parent.Err())
            case &lt;-child.Done():
            }
        }()
    }
}

// 此函数判断查找父cancelCtx对象
func parentCancelCtx(parent Context) (*cancelCtx, bool) {
    for {
        switch c := parent.(type) {
        case *cancelCtx:
            return c, true
        case *timerCtx:
            return &amp;c.cancelCtx, true
        case *valueCtx:
            parent = c.Context
        default:
            return nil, false
        }
    }
}
</code></pre>

<p>cancelCtx实现：</p>

<pre><code>// cancelCtx结构体定义
type cancelCtx struct {
    Context
    done chan struct{} // closed by the first cancel call.
    mu       sync.Mutex
    children map[canceler]struct{} // set to nil by the first cancel call
    err      error                 // set to non-nil by the first cancel call
}

// 实现Context接口Done方法，返回channel
func (c *cancelCtx) Done() &lt;-chan struct{} {
    return c.done
}
</code></pre>

<p>   // 实现Context接口Err方法，返回错误原因
    func (c *cancelCtx) Err() error {
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.err
    }</p>

<pre><code>// 以字符串形式打印对象
func (c *cancelCtx) String() string {
    return fmt.Sprintf("%v.WithCancel", c.Context)
}

// cacel关闭c.done通道，取消所有子Context对象，并且从父对象中删除
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    if err == nil {
        panic("context: internal error: missing cancel error")
    }   
    c.mu.Lock()
    if c.err != nil {
        c.mu.Unlock()
        return // already canceled
    }
    c.err = err
    close(c.done)
    for child := range c.children {
        // NOTE: acquiring the child's lock while holding parent's lock.
    child.cancel(false, err)
    }
    c.children = nil
    c.mu.Unlock()

    if removeFromParent {
        removeChild(c.Context, c)
    }
}
</code></pre>

<h2><span id="WithDeadline">WithDealine</span></h2>

<p>WithDeadline创建一个具有超时时间的Conetext对象</p>

<pre><code>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
    if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) {
    //如果父Context的超时时间更早
        return WithCancel(parent)
    }
    c := &amp;timerCtx{
        cancelCtx: newCancelCtx(parent),
        deadline:  deadline,
    }
    propagateCancel(parent, c)
    d := time.Until(deadline)
    if d &lt;= 0 {
        c.cancel(true, DeadlineExceeded) // 超时时间已过
        return c, func() { c.cancel(true, Canceled) }
    }
    c.mu.Lock()
    defer c.mu.Unlock()
    if c.err == nil {
        c.timer = time.AfterFunc(d, func() {
            c.cancel(true, DeadlineExceeded)
        })
    }
    return c, func() { c.cancel(true, Canceled) }
}
</code></pre>

<h2><span id="WithValue"> WithValue </span></h2>

<pre><code>//返回一个Context接口对象，这个对象包含一个key、value对  // key必须是可比较的
func WithValue(parent Context, key, val interface{}) Context {
    if key == nil {
        panic("nil key")
    }
    if !reflect.TypeOf(key).Comparable() {
        panic("key is not comparable")
    }
    return &amp;valueCtx{parent, key, val}
}

// valueCtx包含一个键值对，它实现了Value接口方法
// 它将接口的其他方法委托给Context父对象
type valueCtx struct {
    Context
    key, val interface{}
}


func (c *valueCtx) String() string {
    return fmt.Sprintf("%v.WithValue(%#v, %#v)", c.Context, c.key, c.val)
}

func (c *valueCtx) Value(key interface{}) interface{} {
    if c.key == key {
        return c.val
    }
    return c.Context.Value(key)
}
</code></pre>

<h2>参考</h2>

<p><a href="https://blog.golang.org/context">context</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用daemontools管理进程]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/10/19/shi-yong-daemontoolsguan-li-jin-cheng/"/>
    <updated>2017-10-19T11:23:50+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/10/19/shi-yong-daemontoolsguan-li-jin-cheng</id>
    <content type="html"><![CDATA[<p>本片博客介绍如何使用<a href="http://cr.yp.to/daemontools.html">daemontools</a>管理在后台一直运行的进程，当程序异常退出时，deemontools可以将进程重新拉起。</p>

<h2>安装</h2>

<p>deemontools只可以运行在UNIX系统。<br/>
步骤：</p>

<ul>
<li><p>创建<code>/package</code>目录</p>

<pre><code>  mkdir -p /package  
  chmod 1755 /package  
  cd /package  
</code></pre></li>
<li><p>下载<a href="http://cr.yp.to/daemontools/daemontools-0.76.tar.gz">daemontools-0.76.tar.gz</a></p>

<pre><code>  cd /package  
  wget http://cr.yp.to/daemontools/daemontools-0.76.tar.gz  
  tar xzvf daemontools-0.76.tar.gz   
  cd admin/daemontools   
</code></pre></li>
<li><p>编译安装</p>

<pre><code>  package/install
</code></pre>

<p>在CentOS 7上编译时报错：</p>

<pre><code>  /usr/bin/ld: errno: TLS defini  tion in /lib/libc.so.6 section .tbss mismatches non-TLS reference in envdir.o
</code></pre>

<p>解决方法如下：</p>

<pre><code>  将admin/daemontools-0.76/src/error.h中的extern int errno;替换为#include &lt;errno.h&gt;
</code></pre>

<p>安装完成后会自动创建<code>/command  /service</code>两个目录，command目录下面包含各种daemontools工具 service目录包含daemontools管理的服务</p></li>
</ul>


<!-- more -->


<h2>配置daemontools开机启动</h2>

<p>CentOS 7使用systemd来管理服务，新建/etc/systemd/system/daemontools.service文件，将如下内容放到新建文件中：</p>

<pre><code>    [Unit]
    Description=daemontools Start supervise
    After=getty.target
    [Service]
    Type=simple
    User=root
    Group=root
    Restart=always
    ExecStart=/command/svscanboot /dev/ttyS0
    TimeoutSec=0
    [Install]
    WantedBy=multi-user.target
</code></pre>

<ul>
<li><p>启动服务</p>

<pre><code>  systemctl start deamontools.service
</code></pre></li>
<li><p>查看服务状态</p>

<pre><code>  systemctl status deamontools.service
</code></pre></li>
<li><p>设置开机启动</p>

<pre><code>  systemctl enable daemontools.service
</code></pre></li>
</ul>


<h2>使用daemontools管理进程</h2>

<p>   daemontools.service服务的启动进程为/command/svscanboot，查看svscanboot程序的进程树：</p>

<pre><code>    [root@hq-test command]# ps aux | grep svs
    root     19658  0.0  0.0 113116  1428 ?        Ss   Oct18   0:00 /bin/sh /command/svscanboot /dev/ttyS0
    root     19660  0.0  0.0   4344   480 ?        S    Oct18   0:00 svscan /service
    root     30566  0.0  0.0 112640   956 pts/0    R+   14:35   0:00 grep --color=auto svs
    [root@hq-test command]# pstree -ap 19658
    svscanboot,19658 /command/svscanboot /dev/ttyS0
      ├─readproctitle,19661 service errors:...
        └─svscan,19660 /service
              └─supervise,20625 test
                        └─test,22043
</code></pre>

<p>   通过进程树我们看到svscanboot进程启动svscan进程，svscan读取/service目录，svscan启动supervise进程管理我们的应用进程test
   下面讲解如何向daemontools添加一个应用进程:<br/>
   应用进程所在目录为：<code>/tmp/test</code></p>

<pre><code>    [root@hq-test test]# ls
    test
    [root@hq-test test]#
</code></pre>

<ul>
<li><p> 在应用进程所在文件夹新建run文件</p>

<pre><code>[root@hq-test test]# cat run
#!/bin/sh
exec /tmp/test/test 1&gt;&gt;/tmp/test/1.out 2&gt;&amp;1
[root@hq-test test]# pwd
/tmp/test
[root@hq-test test]# ls
run  test
[root@hq-test test]#
</code></pre>

<ul>
<li><p>向svscanboot注册服务</p>

<p>  [root@hq-test test]# ln -s /tmp/test /service/test
  [root@hq-test test]# ls /service/
  test
  [root@hq-test test]# ls -al /service/
  total 8
  drwxr-xr-x   2 root root 4096 Oct 19 17:23 .
  drwxr-xr-x. 23 root root 4096 Oct 18 19:25 ..
  lrwxrwxrwx   1 root root    9 Oct 19 17:23 test -> /tmp/test
  [root@hq-test test]#</p>

<p> 在/service目录中建立到应用程序目录的软连接后，svscan将会新建supervise进程，启动应用进程:</p>

<p>  [root@hq-test test]# pstree -ap 19658
  svscanboot,19658 /command/svscanboot /dev/ttyS0
    ├─readproctitle,19661 service errors:&hellip;
      └─svscan,19660 /service
            └─supervise,5821 test
                      └─test,5822</p></li>
<li><p>查看服务状态
  svstat services
  services 为/service目录下的软链接</p>

<p>  [root@hq-test test]# svstat /service/test/
  /service/test/: up (pid 5822) 303 seconds</p></li>
<li><p>管理服务</p>

<p> svc opts services
 opts包含如下选项：</p>

<pre><code>  -u: Up。 如果服务不在运行，启动服务。如果服务停止了，重启服务。  
  -d: Down。 如果服务在运行，发送一个TERM信号，之后发送CONT信号。服务停止后，不重启服务。  
  -o: Once。如果服务不在运行，则启动服务。服务停止后，不在启动服务。  
  -p: Pause。向服务发送STOP信号。  
  -c: Continue。向服务发送一个CONT信号。  
  -h: Hangup。向服务发送一个HUP信号。  
  -a: Alarm。向服务发送一个ALARM信号。  
  -i: Interrupt。向服务发送一个INT信号。  
  -t: Terminate。向服务发送一个TERM信号。  
  -k: Kill。 向服务发送一个KILL信号。  
  -x: Exit。服务进程退出后supervise将会退出。  
</code></pre>

<p>停止服务进程：</p>

<pre><code>  [root@hq-test test]# pstree -pa 19658
  svscanboot,19658 /command/svscanboot /dev/ttyS0
    ├─readproctitle,19661 service errors:...
      └─svscan,19660 /service
            └─supervise,10630 test
                      └─test,10631
  [root@hq-test test]# svstat /service/test/
  /service/test/: up (pid 10631) 67 seconds
  [root@hq-test test]# svc -d /service/test/
  [root@hq-test test]# svstat /service/test/
  /service/test/: down 5 seconds, normally up
  [root@hq-test test]#
</code></pre></li>
</ul>


<p> 重启服务进程：</p>

<pre><code>   [root@hq-test test]# svc -u /service/test/
   [root@hq-test test]# svstat /service/test/
   /service/test/: up (pid 10750) 2 seconds
   [root@hq-test test]# pstree -pa 19658
   svscanboot,19658 /command/svscanboot /dev/ttyS0
     ├─readproctitle,19661 service errors:...
       └─svscan,19660 /service
             └─supervise,10630 test
                       └─test,10750
   [root@hq-test test]# svstat /service/test/
   /service/test/: up (pid 10750) 12 seconds
   [root@hq-test test]#
</code></pre>

<p>删除服务：<br/>
       先删除/service目录中的服务链接，
       svc 命令中使用服务的目标链接</p>

<pre><code>   [root@hq-test test]# rm /service/test
   rm: remove symbolic link ‘/service/test’? y
   [root@hq-test test]# svc -dx /tmp/test
   [root@hq-test test]# pstree -pa 19658
   svscanboot,19658 /command/svscanboot /dev/ttyS0
     ├─readproctitle,19661 service errors:...
       └─svscan,19660 /service
   [root@hq-test test]#
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="http://cr.yp.to/daemontools/svc.html">daemontools</a></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RabbitMQ 入门实践]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/09/21/rabbitmq-ru-men-shi-jian/"/>
    <updated>2017-09-21T20:31:11+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/09/21/rabbitmq-ru-men-shi-jian</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用strace调试进程]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/09/04/shi-yong-stracediao-shi-jin-cheng/"/>
    <updated>2017-09-04T18:44:00+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/09/04/shi-yong-stracediao-shi-jin-cheng</id>
    <content type="html"><![CDATA[<p><code>Strace</code>调试工具可以帮助定位问题。  <br/>
<code>Strace</code>工具可以用来记录指定程序运行过程中涉及的系统调用和信号。在没有获取程序源代码的情况下，strace工具可以有效帮助对程序的调试。strace工具提供一个二进制程序从开始到结束的执行顺序。  <br/>
下面几个例子展示如何使用<code>strace</code>工具：</p>

<!-- more -->


<ol>
<li><p>跟踪可执行程序的执行<br/>
可以使用strace工具跟踪任何可执行程序的执行。下面例子是使用strace跟踪linux ls命令的执行过程：</p>

<pre><code class="``">$  strace ls
execve("/bin/ls", ["ls"], [/* 21 vars */]) = 0
brk(0)                                  = 0x8c31000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb78c7000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=65354, ...}) = 0
...
...
...
</code></pre></li>
<li><p>使用-e参数跟踪特定系统调用<br/>
strace默认跟踪执行程序的所有系统调用。可以使用<code>-e</code>参数跟踪特定系统调用：</p>

<pre><code class="``">$ strace -e open ls
open("/etc/ld.so.cache", O_RDONLY)      = 3
open("/lib/libselinux.so.1", O_RDONLY)  = 3
open("/lib/librt.so.1", O_RDONLY)       = 3
open("/lib/libacl.so.1", O_RDONLY)      = 3
open("/lib/libc.so.6", O_RDONLY)        = 3
open("/lib/libdl.so.2", O_RDONLY)       = 3
open("/lib/libpthread.so.0", O_RDONLY)  = 3
open("/lib/libattr.so.1", O_RDONLY)     = 3
open("/proc/filesystems", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = 3
open(".", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
Desktop  Documents  Downloads  examples.desktop  libflashplayer.so 
Music  Pictures  Public  Templates  Ubuntu_OS  Videos
</code></pre>

<p>如果想执行多个系统调用，可以使用<code>-e trace=</code>选项。下面例子跟踪open和read系统调用：</p>

<pre><code class="``">  $ strace -e trace=open,read ls /home
open("/etc/ld.so.cache", O_RDONLY)      = 3
open("/lib/libselinux.so.1", O_RDONLY)  = 3
read(3, "\177ELF\1\1\1\3\3\1\260G004"..., 512) = 512
open("/lib/librt.so.1", O_RDONLY)       = 3
read(3, "\177ELF\1\1\1\3\3\1\300\30004"..., 512) = 512
..
open("/lib/libattr.so.1", O_RDONLY)     = 3
read(3, "\177ELF\1\1\1\3\3\1\360\r004"..., 512) = 512
open("/proc/filesystems", O_RDONLY|O_LARGEFILE) = 3
read(3, "nodev\tsysfs\nnodev\trootfs\nnodev\tb"..., 1024) = 315
read(3, "", 1024)                       = 0
open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = 3
open("/home", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
bala
</code></pre></li>
<li><p>保存调用过程到文件<br/>
下面例子使用<code>-o</code>参数保存调用过程到文件中：</p>

<pre><code class="``">  $ strace -o output.txt ls
  Desktop  Documents  Downloads  examples.desktop  libflashplayer.so
Music  output.txt  Pictures  Public  Templates  Ubuntu_OS  Videos

  $ cat output.txt 
execve("/bin/ls", ["ls"], [/* 37 vars */]) = 0
brk(0)                                  = 0x8637000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7860000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=67188, ...}) = 0
...
...
</code></pre></li>
<li><p>使用<code>-p</code>参数跟踪正在运行的进程<br/>
 先使用ps命令获取正在运行进程的id<br/>
 <code>
 $ ps -C firefox-bin
   PID TTY          TIME CMD
 1725 ?        00:40:50 firefox-bin
</code>
 使用<code>-p</code>指定strace需要跟踪进程的id</p>

<pre><code class="`"> $ sudo strace -p 1725 -o firefox_trace.txt

 $ tail -f firefox_trace.txt
</code></pre>

<p> 进程系统调用将会被写入到文件中，使用tail命令可以查看最近执行序列。</p></li>
<li><p>使用<code>-t</code>参数为每行输出显示时间戳</p>

<pre><code class="`"> $ strace -t -e open ls /home
20:42:37 open("/etc/ld.so.cache", O_RDONLY) = 3
20:42:37 open("/lib/libselinux.so.1", O_RDONLY) = 3
20:42:37 open("/lib/librt.so.1", O_RDONLY) = 3
20:42:37 open("/lib/libacl.so.1", O_RDONLY) = 3
20:42:37 open("/lib/libc.so.6", O_RDONLY) = 3
20:42:37 open("/lib/libdl.so.2", O_RDONLY) = 3
20:42:37 open("/lib/libpthread.so.0", O_RDONLY) = 3
20:42:37 open("/lib/libattr.so.1", O_RDONLY) = 3
20:42:37 open("/proc/filesystems", O_RDONLY|O_LARGEFILE) = 3
20:42:37 open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = 3
20:42:37 open("/home", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
bala
</code></pre></li>
<li><p>使用<code>-r</code>参数输出每个系统调用执行时间</p>

<pre><code class="`"> $ strace -r ls 
  0.000000 execve("/bin/ls", ["ls"], [/* 37 vars */]) = 0
  0.000846 brk(0)                    = 0x8418000
  0.000143 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
  0.000163 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb787b000
  0.000119 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
  0.000123 open("/etc/ld.so.cache", O_RDONLY) = 3
  0.000099 fstat64(3, {st_mode=S_IFREG|0644, st_size=67188, ...}) = 0
  0.000155 mmap2(NULL, 67188, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb786a000
  ...
  ...
</code></pre></li>
<li><p>使用<code>-c</code>参数显示系统调用统计报告<br/>
 使用<code>-c</code>参数可以输出程序执行期间系统调用的统计数据：包括执行时间占比，执行时间，执行次数，错误数:</p>

<pre><code> $ strace -c ls /home
 bala
 % time     seconds  usecs/call     calls    errors syscall
 ------ ----------- ----------- --------- --------- ----------------
 -nan    0.000000           0         9           read
 -nan    0.000000           0         1           write
 -nan    0.000000           0        11           open


 -nan    0.000000           0        13           close
 -nan    0.000000           0         1           execve
 -nan    0.000000           0         9         9 access
 -nan    0.000000           0         3           brk
 -nan    0.000000           0         2           ioctl
 -nan    0.000000           0         3           munmap
 -nan    0.000000           0         1           uname
 -nan    0.000000           0        11           mprotect
 -nan    0.000000           0         2           rt_sigaction
 -nan    0.000000           0         1           rt_sigprocmask
 -nan    0.000000           0         1           getrlimit
 -nan    0.000000           0        25           mmap2
 -nan    0.000000           0         1           stat64
 -nan    0.000000           0        11           fstat64
 -nan    0.000000           0         2           getdents64
 -nan    0.000000           0         1           fcntl64
 -nan    0.000000           0         2         1 futex
 -nan    0.000000           0         1         set_thread_area
 -nan    0.000000           0         1           set_tid_address
 -nan    0.000000           0         1           statfs64
 -nan    0.000000           0         1              set_robust_list
 ------ ----------- ----------- --------- --------- ----------------
 100.00    0.000000                   114        10 total
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 加密包学习与实践]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/08/19/golang-jia-mi-bao-xue-xi-yu-shi-jian/"/>
    <updated>2017-08-19T10:57:59+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/08/19/golang-jia-mi-bao-xue-xi-yu-shi-jian</id>
    <content type="html"><![CDATA[<p>Go标准库<a href="https://golang.org/pkg/crypto/">crypto</a>提供了多种加解密算法、摘要算法。本文主要是对加密包中各个算法接口进行学习实践的总结。</p>

<ul>
<li><p><a href="#aes">aes</a></p></li>
<li><p><a href="#rsa">rsa</a></p></li>
</ul>


<!-- more -->


<h2><span id="aes">aes</span></h2>

<h2><span id="rsa">rsa</span></h2>

<p><a href="https://golang.org/pkg/crypto/rsa/">rsa</a>包实现了<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem">RSA</a>)加密算法，关于<code>RSA</code>的标准为<a href="https://en.wikipedia.org/wiki/PKCS_1">PKCS #1</a>。<br/>
<code>RSA</code>既可以用与加解密也可以用与签名。<br/>
使用RSA进行加密和签名的最初标准是<code>PKCS#1</code>，<code>RSA encryption</code>和<code>RSA signatures</code>默认参照<code>PKCS#1</code>1.5版本。但是这个版本的标注存在缺陷，新的的设计应该参照第二版本，以<code>OAEP</code>和<code>PSS</code>称呼。</p>

<p><code>rsa</code>包中的相关操作不是常量时间复杂度。 <br/>
对使用包中进行加解密操作和签名操作进行说明：</p>

<blockquote><p>生成key</p></blockquote>

<pre><code>func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)
</code></pre>

<p><code>random</code>为随机数源，比如<code>crypto/rand.Reader</code> <br/>
<code>bits</code>为密钥位数，目前建议是2048位</p>

<blockquote><p>加密</p></blockquote>

<pre><code>func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)
</code></pre>

<p><code>EncryptOAEP</code>函数对消息体进行加密。<br/>
<code>hash</code>参数是一个哈希函数。对同一消息进行加解密必须使用同一种哈希函数，<code>sha256.New()</code>是一个合理选择。<br/>
<code>random</code>参数为随机数源，用来保证对同一个消息体进行两次加密时的输出不同。<br/>
<code>label</code>参数可以包含任意数据，这些数据不会被加密，标签参数给消息增加了重要的上下文信息。加解密时传入的<code>label</code>标签需要一致。如果不需要，可以为空。
<code>msg</code>待加密消息长度必须小于等于公钥长度减去2倍哈希长度。</p>

<blockquote><p>解密</p></blockquote>

<pre><code>func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)
</code></pre>

<p><code>hash</code>加解密使用的哈希函数必须一致，<code>sha256.New()</code>是一个合理选择。<br/>
<code>random</code>随机数源。<br/>
<code>label</code>参数值必须与加密时传入的值一致。</p>

<blockquote><p>加解密实践</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func TestCrypt() {
</span><span class='line'>    //create private key
</span><span class='line'>    privateKey, err := rsa.GenerateKey(rand.Reader,2048)
</span><span class='line'>    if err != nil {
</span><span class='line'>        log.Fatal("generateKey err ",err)
</span><span class='line'>        return
</span><span class='line'>    }
</span><span class='line'>    // encrypt
</span><span class='line'>    ciphertext, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, &privateKey.PublicKey, []byte("hahaha"), []byte("label"))
</span><span class='line'>    if err != nil {
</span><span class='line'>        log.Fatal("encrypt err ", err)
</span><span class='line'>        return
</span><span class='line'>    }
</span><span class='line'>    log.Printf("Ciphertext: %x\n", ciphertext)
</span><span class='line'>    log.Println(hex.EncodeToString(ciphertext))
</span><span class='line'>    plaintext, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, []byte("label"))
</span><span class='line'>    if err != nil || bytes.Compare([]byte("hahaha"), plaintext) != 0 {
</span><span class='line'>        log.Fatal("decrypt err: ", err)
</span><span class='line'>        return
</span><span class='line'>    }
</span><span class='line'>    log.Println("plaintext :", string(plaintext))
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>签名</p></blockquote>

<pre><code>func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) ([]byte, error)
</code></pre>

<p><code>rand</code>为随机数源。<br/>
<code>priv</code>为进行签名用到的私钥。<br/>
<code>SignPSS</code>函数依据<code>RSASSA-PSS</code>标准计算摘要数据的签名。注意：摘要数据必须是使用指定哈希函数对输入数据计算得出的摘要值。<code>opts</code>参数可以为空，此时使用默认值。</p>

<blockquote><p>验证签名</p></blockquote>

<pre><code>func VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions) error
</code></pre>

<p>VerifyPSS验证PSS签名。<code>hashed</code>是使用指定函数对输入数据计算得出的摘要值。sig为签名数据。opts可以为空。</p>

<blockquote><p>签名实践</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func TestSign() {
</span><span class='line'>    //create private key
</span><span class='line'>    privateKey, err := rsa.GenerateKey(rand.Reader,2048)
</span><span class='line'>    if err != nil {
</span><span class='line'>        log.Fatal("generateKey err ",err)
</span><span class='line'>        return
</span><span class='line'>    }
</span><span class='line'>    // sign
</span><span class='line'>    hashed := sha256.Sum256([]byte("hahaha"))
</span><span class='line'>    /*
</span><span class='line'>    opts := rsa.PSSOptions{
</span><span class='line'>       SaltLength:10,
</span><span class='line'>        Hash:crypto.SHA256,
</span><span class='line'>    }
</span><span class='line'>    */
</span><span class='line'>    sig, err := rsa.SignPSS(rand.Reader,privateKey, crypto.SHA256,  hashed[:], nil)
</span><span class='line'>    if err != nil {
</span><span class='line'>        log.Fatal("SignPSS err ", err)
</span><span class='line'>        return
</span><span class='line'>    }
</span><span class='line'>    log.Println(hex.EncodeToString(sig))
</span><span class='line'>    err = rsa.VerifyPSS(&privateKey.PublicKey, crypto.SHA256, hashed[:], sig, nil)
</span><span class='line'>    if err != nil {
</span><span class='line'>        log.Fatal("VerifyPSS err", err)
</span><span class='line'>        return
</span><span class='line'>    }
</span><span class='line'>    log.Println("VerifyPSS suc")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openssl实战]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/08/09/opensslshi-zhan/"/>
    <updated>2017-08-09T17:50:42+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/08/09/opensslshi-zhan</id>
    <content type="html"><![CDATA[<p>本篇文章主要是对openssl的使用进行实践总结。</p>

<ul>
<li><a href="#key">生成密钥</a></li>
<li><a href="#crt">创建证书</a></li>
<li><a href="#practice">实践</a></li>
</ul>


<!-- more -->


<h2><span id="key">生成密钥</span></h2>

<h3>生成RSA密钥</h3>

<p>命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>openssl genrsa [-out filename] [-passout arg] [-aes128] [-aes128] [-aes192] [-aes256] [-camellia128] [-camellia192] [-camellia256] [-aes192]
</span><span class='line'>       [-aes256] [-camellia128] [-camellia192] [-camellia256] [-des] [-des3] [-idea] [-f4] [-3] [-rand file(s)] [-engine id] [numbits]</span></code></pre></td></tr></table></div></figure>


<p>参数：<br/>
<code>-out filename</code> 输出到结果文件。如果不指定，则输出到标准输出。<br/>
<code>-aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea</code> <br/>
指定加密算法加密密钥。<br/>
<code>numbits</code>指定密钥位数。默认为512位</p>

<p>生成一个2048位rsa非对称密钥，保存到rsa-fd.key文件中：</p>

<pre><code>openssl genrsa -out rsa-fd.key 2048
</code></pre>

<p><code>rsa-fd.key</code>文件为<code>PEM</code>格式：</p>

<pre><code>$ file rsa-fd.key
rsa-fd.key: PEM RSA private key
</code></pre>

<p>使用<code>rsa</code>命令解析出私钥结构：</p>

<pre><code>openssl rsa -text -in rsa-fd.key
</code></pre>

<p>查看私钥中的公开部分：</p>

<pre><code>openssl rsa -in rsa-fd.key -pubout -out rsa-pub.key
</code></pre>

<h3>生成DSA密钥</h3>

<p>DSA的密钥生成分成两个部分:先生成DSA的参数，然后再生成密钥。
命令：</p>

<pre><code>openssl dsaparam -genkey 2048 | openssl dsa -out dsa.key
</code></pre>

<h3>生成ECDSA密钥</h3>

<p>创建ECDSA密钥的过程是类似的，但是不能创建任意长度的密钥。对于每个密钥，你需要选择一个命名曲线(named curve)，它可以控制密钥长度，同时也限定了椭圆曲线的参数。下面的例子使用secp256r1这个命名曲线创建一个256位长度的ECDSA密钥</p>

<pre><code>openssl ecparam -genkey -name secp256r1 | openssl ec -out ec.key
</code></pre>

<h2><span id="crt">创建证书</span></h2>

<h3>创建证书申请</h3>

<blockquote><p>使用openssl req命令交互式生成创建证书申请：</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ openssl req -new -key rsa-fd.key -out rsa-fd.csr
</span><span class='line'>You are about to be asked to enter information that will be incorporated
</span><span class='line'>into your certificate request.
</span><span class='line'>What you are about to enter is what is called a Distinguished Name or a DN.
</span><span class='line'>There are quite a few fields but you can leave some blank
</span><span class='line'>For some fields there will be a default value,
</span><span class='line'>If you enter '.', the field will be left blank.
</span><span class='line'>-----
</span><span class='line'>Country Name (2 letter code) [AU]:CN
</span><span class='line'>State or Province Name (full name) [Some-State]:ShangHai
</span><span class='line'>Locality Name (eg, city) []:ShangHai
</span><span class='line'>Organization Name (eg, company) [Internet Widgits Pty Ltd]:limo
</span><span class='line'>Organizational Unit Name (eg, section) []:limo
</span><span class='line'>Common Name (e.g. server FQDN or YOUR name) []:localhost
</span><span class='line'>Email Address []:.
</span><span class='line'>
</span><span class='line'>Please enter the following 'extra' attributes
</span><span class='line'>to be sent with your certificate request
</span><span class='line'>A challenge password []:.
</span><span class='line'>An optional company name []:.
</span><span class='line'>$</span></code></pre></td></tr></table></div></figure>


<p>其中<code>Common Name</code>指定证书保护的域名。</p>

<blockquote><p>使用openssl req查看证书申请内容：</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Data:
</span><span class='line'>        Version: 0 (0x0)
</span><span class='line'>        Subject: C=CN, ST=ShangHai, L=ShangHai, O=limo, OU=limo, CN=localhost
</span><span class='line'>        Subject Public Key Info:
</span><span class='line'>            Public Key Algorithm: rsaEncryption
</span><span class='line'>            RSA Public Key: (2048 bit)
</span><span class='line'>                Modulus (2048 bit):
</span><span class='line'>                    00:c0:2b:11:a0:53:7d:fa:83:7f:29:2b:b5:dc:bc:
</span><span class='line'>                Exponent: 65537 (0x10001)
</span><span class='line'>        Attributes:
</span><span class='line'>            a0:00
</span><span class='line'>Signature Algorithm: sha1WithRSAEncryption
</span><span class='line'>        7c:3d:47:49:d5:f7:c9:89:65:81:62:3d:bb:84:b8:ed:70:c4:
</span><span class='line'>        e8:ba:ae:03:2e:af:3a:cb:31:07:e3:ef:57:a1:c7:a8:a6:c8:</span></code></pre></td></tr></table></div></figure>


<blockquote><p>使用配置文件生成证书：</p></blockquote>

<p>配置文件内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[req]
</span><span class='line'>prompt = no
</span><span class='line'>distinguished_name = dn
</span><span class='line'>req_extensions     = ext
</span><span class='line'>
</span><span class='line'>[dn]
</span><span class='line'>CN      = localhost
</span><span class='line'>O       = limo
</span><span class='line'>L       = ShangHai
</span><span class='line'>C       = CN
</span><span class='line'>
</span><span class='line'>[ext]
</span><span class='line'>subjectAltName = DNS:www.localhost.com,DNS:localhost</span></code></pre></td></tr></table></div></figure>


<p>执行命令如下：</p>

<pre><code>$ openssl req -new -config rsa-fd.conf -key rsa-fd.key -out t.csr
</code></pre>

<h3>自签名证书</h3>

<p>如果已经有了csr，则执行以下命令创建证书：</p>

<pre><code>$ openssl x509 -req -days 365 -in rsa-fd.csr -signkey rsa-fd.key -out rsa-fd.crt
Signature ok
subject=/C=CN/ST=ShangHai/L=ShangHai/O=limo/OU=limo/CN=localhost
Getting Private key
</code></pre>

<h2><span id="practice"> 实践 </span></h2>

<blockquote><p>创建根CA证书</p></blockquote>

<ol>
<li><p>创建rsa密钥</p>

<pre><code class="`"> $ openssl genrsa -out ca.key 2048  
 Generating RSA private key, 2048 bit long modulus  
 ........+++  
 ..................................................+++  
 e is 65537 (0x10001)  
</code></pre></li>
<li><p>创建证书申请</p>

<pre><code> $ openssl genrsa -out ca.key 2048 -out ca.csr
 $ 
</code></pre></li>
<li><p>创建自签名证书</p>

<pre><code> $ openssl x509 -req -in ca.csr -signkey ca.key  -out ca.crt
 Signature ok
 subject=/C=CN/ST=ShangHai/L=ShangHai/O=li/OU=li/CN=RootCA
 Getting Private key
</code></pre></li>
</ol>


<blockquote><p>创建client密钥和证书</p></blockquote>

<ol>
<li><p>创建rsa密钥</p>

<pre><code class="`"> $ openssl genrsa -out client.key 2048
Generating RSA private key, 2048 bit long modulus
..................................+++
..........+++
e is 65537 (0x10001)
</code></pre></li>
<li><p>创建证书申请</p>

<pre><code> openssl req -new -key client.key -out client.csr
</code></pre></li>
<li><p>使用root CA签名client证书</p>

<pre><code> $ openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt
 Signature ok
 subject=/C=CN/ST=ShangHai/L=SH/O=li/OU=li/CN=localhost  
 Getting CA Private Key
</code></pre>

<p>需要增加<code>-CAcreateserial</code>参数否则报错</p></li>
</ol>


<blockquote><p>创建server密钥和证书</p></blockquote>

<p>方法同生成client密钥证书类似</p>

<blockquote><p>使用Go创建https server，并对客户端进行双向验证：</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func HelloServer(w http.ResponseWriter, req *http.Request) {
</span><span class='line'>  w.Header().Set("Content-Type", "text/plain")
</span><span class='line'>  w.Write([]byte("This is an example server.\n"))
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  pool := x509.NewCertPool()
</span><span class='line'>  caPath := "ca.crt"
</span><span class='line'>  caCrt, err := ioutil.ReadFile(caPath)
</span><span class='line'>  if err != nil {
</span><span class='line'>      fmt.Println("ReadFile err ", err)
</span><span class='line'>      return
</span><span class='line'>  }
</span><span class='line'>  ok := pool.AppendCertsFromPEM(caCrt);
</span><span class='line'>  if !ok {
</span><span class='line'>      fmt.Println("append err")
</span><span class='line'>      return
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  fmt.Println(ok)
</span><span class='line'>  tlsConfig := &tls.Config{
</span><span class='line'>      ClientCAs:pool,
</span><span class='line'>      ClientAuth: tls.RequireAndVerifyClientCert,
</span><span class='line'>  }
</span><span class='line'>  server := http.Server{
</span><span class='line'>      Addr:      ":443",
</span><span class='line'>      TLSConfig: tlsConfig,
</span><span class='line'>  }
</span><span class='line'>  http.HandleFunc("/hello", HelloServer)
</span><span class='line'>  err = server.ListenAndServeTLS("server.crt", "server.key")
</span><span class='line'>  log.Fatal(err)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>使用Go创建https client</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func main() {
</span><span class='line'>  pool := x509.NewCertPool()
</span><span class='line'>  caPath := "ca.crt"
</span><span class='line'>  caCrt, err := ioutil.ReadFile(caPath)
</span><span class='line'>  if err != nil {
</span><span class='line'>      fmt.Println("ReadFile err:", err)
</span><span class='line'>      return
</span><span class='line'>  }
</span><span class='line'>  pool.AppendCertsFromPEM(caCrt)
</span><span class='line'>  cliCrt, err := tls.LoadX509KeyPair("client.crt", "client.key")
</span><span class='line'>  if err != nil {
</span><span class='line'>      fmt.Println("Loadx509keypair err:", err)
</span><span class='line'>      return
</span><span class='line'>  }
</span><span class='line'>  tlsConfig := &tls.Config{
</span><span class='line'>      RootCAs:      pool,
</span><span class='line'>      Certificates: []tls.Certificate{cliCrt},
</span><span class='line'>      InsecureSkipVerify:true,
</span><span class='line'>  }
</span><span class='line'>  tr := http.Transport{TLSClientConfig: tlsConfig}
</span><span class='line'>  client := http.Client{Transport: &tr}
</span><span class='line'>  url := "https://localhost/hello"
</span><span class='line'>  resp, err := client.Get(url)
</span><span class='line'>  if err != nil {
</span><span class='line'>      panic(err)
</span><span class='line'>  }
</span><span class='line'>  data, err := ioutil.ReadAll(resp.Body)
</span><span class='line'>  fmt.Println(string(data))
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/jintao-zero/go-practice/tree/master/https">code</a></p>

<h2>参考</h2>

<ol>
<li><a href="">https权威指南</a></li>
<li><a href="http://tonybai.com/2015/04/30/go-and-https/">Go和HTTPS</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zookeeper实战]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/08/09/zookeepershi-zhan/"/>
    <updated>2017-08-09T15:57:12+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/08/09/zookeepershi-zhan</id>
    <content type="html"><![CDATA[<p>zookeeper实战记录</p>

<ul>
<li><a href="#setup">环境搭建</a></li>
<li><a href="#cmd">命令行操作</a></li>
<li><a href="#code">编程</a></li>
</ul>


<h2><span id="setup">环境搭建</span></h2>

<p>搭建适合生产环境使用的zookeeper集群，最好是大于等于3台机器</p>

<ol>
<li><p><a href="http://zookeeper.apache.org/releases.html">下载</a></p></li>
<li><p>解压</p>

<p> <code>tar xzf zookeeper***.tar.gz</code></p></li>
<li><p>修改配置文件<br/>
 进入解压目录conf子目录<br/>
 <code>cp zoo_sample.cfg zoo.cfg</code><br/>
 修改配置文件 <br/>
 设置相关参数：<br/>
 dataDir为zookeeper持久化数据存放目录   <br/>
 dataDir=/data/zookeeper
 配置集群中三台机器
 server.1=10.174.176.156:2888:3888
 server.2=10.168.106.149:2888:3888
 server.3=10.168.37.52:2888:3888<br/>
 需要在每台机器dataDir目录下建立myid文件，并将上面server后面对应的id写入myid文件中</p></li>
<li><p>启动程序<br/>
 bin/zkServer.sh start</p></li>
<li><p>查看日志文件<br/>
 tail -f zookeeper.out</p></li>
</ol>


<!-- more -->


<h2><span id="cmd">命令行操作</span></h2>

<p><code>bin/zkCli.sh -server 127.0.0.1:2181</code><br/>
连接zookeeper服务端。<br/>
查看<code>help</code>帮助命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[zk: 127.0.0.1:2181(CONNECTED) 0] help  
</span><span class='line'>ZooKeeper -server host:port cmd args
</span><span class='line'>  stat path [watch]
</span><span class='line'>  set path data [version]
</span><span class='line'>  ls path [watch]
</span><span class='line'>  delquota [-n|-b] path
</span><span class='line'>  ls2 path [watch]
</span><span class='line'>  setAcl path acl
</span><span class='line'>  setquota -n|-b val path
</span><span class='line'>  history
</span><span class='line'>  redo cmdno
</span><span class='line'>  printwatches on|off
</span><span class='line'>  delete path [version]
</span><span class='line'>  sync path
</span><span class='line'>  listquota path
</span><span class='line'>  rmr path
</span><span class='line'>  get path [watch]
</span><span class='line'>  create [-s] [-e] path data acl
</span><span class='line'>  addauth scheme auth
</span><span class='line'>  quit
</span><span class='line'>  getAcl path
</span><span class='line'>  close
</span><span class='line'>  connect host:port
</span><span class='line'>[zk: 127.0.0.1:2181(CONNECTED) 1]</span></code></pre></td></tr></table></div></figure>


<p>新建节点：</p>

<pre><code>[zk: 127.0.0.1:2181(CONNECTED) 2] create /test  test_data
Created /test
[zk: 127.0.0.1:2181(CONNECTED) 3]
</code></pre>

<p>查看节点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[zk: 127.0.0.1:2181(CONNECTED) 4] ls /test
</span><span class='line'>[]
</span><span class='line'>[zk: 127.0.0.1:2181(CONNECTED) 5] get /test
</span><span class='line'>test_data
</span><span class='line'>cZxid = 0x10000002a
</span><span class='line'>ctime = Wed Aug 09 16:26:43 CST 2017
</span><span class='line'>mZxid = 0x10000002a
</span><span class='line'>mtime = Wed Aug 09 16:26:43 CST 2017
</span><span class='line'>pZxid = 0x10000002a
</span><span class='line'>cversion = 0
</span><span class='line'>dataVersion = 0
</span><span class='line'>aclVersion = 0
</span><span class='line'>ephemeralOwner = 0x0
</span><span class='line'>dataLength = 9
</span><span class='line'>numChildren = 0
</span><span class='line'>[zk: 127.0.0.1:2181(CONNECTED) 6]</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang加两遍读锁导致程序死锁问题分析]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/06/20/golangjia-liang-bian-du-suo-dao-zhi-cheng-xu-si-suo-wen-ti-ji-lu/"/>
    <updated>2017-06-20T21:42:04+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/06/20/golangjia-liang-bian-du-suo-dao-zhi-cheng-xu-si-suo-wen-ti-ji-lu</id>
    <content type="html"><![CDATA[<p>golang程序使用读写锁对共享数据进行互斥保护时，注意在同一程序调用栈不要对锁进行多次加锁，这样会导致程序死锁，如下的代码片段就会导致程序死锁：</p>

<pre><code>import (
"sync"
"fmt"
"time"
_ "net/http/pprof"
"net/http"
)

var mutex sync.RWMutex

func f()  {
    fmt.Println("f begin to get Rlock ")
    mutex.RLock()
    defer mutex.RUnlock()
    fmt.Println("f get Rlock suc")
}

func main() {
    mutex.RLock()
    fmt.Println("main get RLock suc")
    defer mutex.RUnlock()

    go http.ListenAndServe(":6060", nil)
    go func() {
        fmt.Println("other goroutine begin to get write lock")
        mutex.Lock()
        defer mutex.Unlock()
        fmt.Println("other goroutine get write lock suc“)
    }()
    time.Sleep(time.Second)
    f()
}
</code></pre>

<p>程序执行结果如下：</p>

<pre><code>MacBook-Pro-2:sync jintao$ go run main.go 
main get RLock suc
other goroutine begin to get write lock
f begin to get Rlock
</code></pre>

<!-- more -->


<p>通过pprof工具查看相关goroutine调用栈：<br/>
main goroutine阻塞在获取读锁的位置：</p>

<pre><code>1 @ 0x102dfca 0x102e0ae 0x103e5a1 0x103e1a4 0x1060869 0x13119c6 0x1311bd7 0x102db7a 0x1059c01
#   0x103e1a3   sync.runtime_Semacquire+0x33    /usr/local/go/src/runtime/sema.go:47
#   0x1060868   sync.(*RWMutex).RLock+0x48  /usr/local/go/src/sync/rwmutex.go:43
#   0x13119c5   main.f+0xa5         /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:15
#   0x1311bd6   main.main+0x136         /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:33
#   0x102db79   runtime.main+0x209      /usr/local/go/src/runtime/proc.go:185
</code></pre>

<p>子goroutine阻塞在获取写锁的位置：</p>

<pre><code>1 @ 0x102dfca 0x102e0ae 0x103e5a1 0x103e1a4 0x106098e 0x1311cb6 0x1059c01
#   0x103e1a3   sync.runtime_Semacquire+0x33    /usr/local/go/src/runtime/sema.go:47
#   0x106098d   sync.(*RWMutex).Lock+0x6d   /usr/local/go/src/sync/rwmutex.go:91
#   0x1311cb5   main.main.func1+0xa5        /Users/jintao/Project/test/Golang/src/goutil/sync/main.go:28
</code></pre>

<p>通过上面的调用栈，我们发现main goroutine在第21行已经获取了读锁，当在调用的函数<code>f</code>第15行再次尝试获取读锁时，程序阻塞。创建的goroutine在第28行尝试获取写所时，协程阻塞。</p>

<h2>分析</h2>

<p>这个是读写锁的一个标准行为。在
<a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Wikipedia &ldquo;Readers–writer lock&rdquo;</a>词条中对读写锁进行了介绍，在<code>Priority policies</code>一节中对<code>reader</code>和<code>writer</code>加锁时的优先级策略进行了说明，不同的优先级策略会给并发和死锁带来不同的影响：</p>

<ul>
<li>读优先策略 <br/>
  读优先允许最大并发，但是如果读并发太多，可能导致写饥饿。<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwji0rOAh9bUAhUW12MKHYx9CvUQFggyMAI&amp;url=http%3A%2F%2Fwww.beck-shop.de%2Ffachbuch%2Fleseprobe%2F9783642320262_Excerpt_001.pdf&amp;usg=AFQjCNEskoEL2n3HKpHGYVWc_XpU4z90nw">Concurrent Programming: Algorithms, Principles, and Foundations</a></li>
<li>写优先策略<br/>
  写优先策略可以避免上面读优先导致的写锁饥饿问题，如果有一个写锁着在等待，系统将会组织任何新reader加读锁成功，一旦当前已经获取的读锁释放完后，即会成功获取写锁。写优先策略相比较与读优先策略，会降低系统的并发性能。相对于读优先策略，写优先策略在实现上的效率要低，因为在获取或者释放读锁或者写锁时，都要操作多个互斥锁。</li>
<li>不指定优先级策略
  这种策略在一定场景下的效率更高</li>
</ul>


<p>从上面Wikipedia关于读写锁的说明看，golang中关于读写锁使用的是写优先策略，下面查看源码，对源码进行分析</p>

<h2>源码解析</h2>

<p>读写锁实现在sync/rwmutex.go文件中</p>

<pre><code>type RWMutex struct {
    w           Mutex  // 获取写锁时，必须获取的互斥量
    writerSem   uint32 // 写锁信号量
    readerSem   uint32 // 读锁信号量
    readerCount int32  // 目前获取的读锁个数
    readerWait  int32  // 需要等待reader释放锁个数
}
</code></pre>

<p><code>加载读锁：</code></p>

<pre><code>// RLock locks rw for reading.
func (rw *RWMutex) RLock() {
    if race.Enabled {
        _ = rw.w.state
        race.Disable()
    }
    if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 {
        // A writer is pending, wait for it.
        runtime_Semacquire(&amp;rw.readerSem)
    }
    if race.Enabled {
        race.Enable()
        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))
    }
}
</code></pre>

<p>每次获取读锁时，都对readerCount计数器进行加1，如果加1后值为负，那么说明有人正在获取写锁。等待readerSem信号量变为正</p>

<p><code>释放读锁：</code></p>

<pre><code>func (rw *RWMutex) RUnlock() {
    if race.Enabled {
        _ = rw.w.state
        race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))
        race.Disable()
    }
    if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 {
        if r+1 == 0 || r+1 == -rwmutexMaxReaders {
            race.Enable()
            panic("sync: RUnlock of unlocked RWMutex")
        }
        // A writer is pending.
        if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 {
            // The last reader unblocks the writer.
            runtime_Semrelease(&amp;rw.writerSem)
        }
    }
    if race.Enabled {
        race.Enable()
    }
}
</code></pre>

<p>释放写锁时，对readerCount减1，说明获取释放一个读锁，如果最新值为负，那么说明有人正在尝试获取写锁，readerWait记录了写锁需要等待的读锁个数，此时将readerWait个数减1，如果个素减为0，说明写锁正在等待的所有reader都已经释放读锁，此时可以释放写锁信号量，让程序获取写锁。</p>

<p><code>获取写锁：</code></p>

<pre><code>func (rw *RWMutex) Lock() {
    if race.Enabled {
        _ = rw.w.state
        race.Disable()
    }
    // First, resolve competition with other writers.
    rw.w.Lock()
    // Announce to readers there is a pending writer.
    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders
    // Wait for active readers.
    if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 {
        runtime_Semacquire(&amp;rw.writerSem)
    }
    if race.Enabled {
        race.Enable()
        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))
        race.Acquire(unsafe.Pointer(&amp;rw.writerSem))
    }
}
</code></pre>

<p>获取写锁时，首先获取互斥锁，这样其他写锁必须等待。然后设置读锁个数为负值，这样后面的reader就无法获取到读锁。如果读锁没有释放，则等待写锁信号量变为正。</p>

<p><code>释放写锁：</code></p>

<pre><code>func (rw *RWMutex) Unlock() {
    if race.Enabled {
        _ = rw.w.state
        race.Release(unsafe.Pointer(&amp;rw.readerSem))
        race.Release(unsafe.Pointer(&amp;rw.writerSem))
        race.Disable()
    }

    // Announce to readers there is no active writer.
    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)
    if r &gt;= rwmutexMaxReaders {
        race.Enable()
        panic("sync: Unlock of unlocked RWMutex")
    }
    // Unblock blocked readers, if any.
    for i := 0; i &lt; int(r); i++ {
        runtime_Semrelease(&amp;rw.readerSem)
    }
    // Allow other writers to proceed.
    rw.w.Unlock()
    if race.Enabled {
        race.Enable()
    }
}
</code></pre>

<p>释放写锁时，将等待获取读锁的个数变为实际值，根据等待获取读锁的个数，释放读锁信号量。</p>

<h2>结论</h2>

<p>根据上面对读写锁源码的分析，我们可以看到golang中读写锁是使用写锁优先策略的，博文开头的例子中，main主协程在已经获取读锁的情况，又尝试第二次获取读锁，因为已经创建了一个子协程在获取写锁，那么第二次获取读锁操作将被阻塞，这样就导致主协程无法释放第一次获取的读锁，从而子协程获取写锁失败，这样整个程序两个写成处于死锁状态。</p>

<h2>参考</h2>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/4sx5pPp8gFw">Lock re-accquision in sync forbiden</a></li>
<li><a href="https://golang.org/pkg/sync/#RWMutex.Lock">Package sync</a></li>
<li><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Readers–writer lock</a></li>
<li><a href="https://stackoverflow.com/questions/30547916/goroutine-blocks-when-calling-rwmutex-rlock-twice-after-an-rwmutex-unlock">goroutine blocks when calling RWMutex RLock twice after an RWMutex Unlock</a></li>
<li><a href="https://github.com/golang/go/issues/15418">sync: document that double RLock isn&rsquo;t safe #15418</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go代码走读规范]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/06/14/godai-ma-zou-du-gui-fan/"/>
    <updated>2017-06-14T19:27:11+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/06/14/godai-ma-zou-du-gui-fan</id>
    <content type="html"><![CDATA[<p>Go代码走读时注意点，非代码规范：</p>

<ul>
<li><a href="#gofmt">Gofmt</a></li>
<li><a href="#Comment%20Sentences">Comment Sentences</a></li>
<li><a href="#Contexts">Contexts</a></li>
<li><a href="#Copying">Copying</a></li>
<li><a href="#Declaring%20Empty%20Slices">Declaring Empty Slices</a></li>
<li><a href="#Crypto%20Rand">Crypto Rand</a></li>
<li><a href="#Doc%20Comments">Doc Comments</a></li>
<li><a href="#Don't%20Panic">Don&rsquo;t Panic</a></li>
<li><a href="#Error%20Strings">Error Strings</a></li>
<li><a href="#Examples">Examples</a></li>
<li><a href="#Goroutine%20Lifetimes">Goroutine Lifetimes</a></li>
<li><a href="#Handle%20Errors">Handle Errors</a></li>
<li><a href="#Import">Import</a></li>
<li><a href="#Import%20Dot">Import Dot</a></li>
<li><a href="#In-Band%20Errors">In-Band Errors</a></li>
<li><a href="#Indent%20Error%20Flow">Indent Error Flow</a></li>
<li><a href="#Initialisms">Initialisms</a></li>
<li><a href="#Interfaces">Interfaces</a></li>
<li><a href="#Mixed%20Caps">Mixed Caps</a></li>
<li><a href="#Named%20Result%20Parameters">Named Result Parameters</a></li>
<li><a href="#Package%20Comments">Package Comments</a></li>
<li><a href="#Package%20Names">Package Names</a></li>
<li><a href="#Pass%20Values">Pass Values</a></li>
<li><a href="#Receiver%20Names">Receiver Names</a></li>
<li><a href="#Receiver%20Type">Receiver Type</a></li>
<li><a href="#Synchronous%20Functions">Synchronous Functions</a></li>
</ul>


<!-- more -->


<h2><span id="Gofmt">Gofmt</span></h2>

<p>使用<a href="https://golang.org/cmd/gofmt/">gofmt</a>工具修复大多数代码风格问题。机会所有Go代码都是用<code>gofmt</code>进行格式化。剩下的非机器可以格式化的代码风格将在本篇文章中进行说明。<br/>
一个替代工具是<code>goimports</code>，它是<code>gofmt</code>工具的一个超集，它会自动增加或者删除引入包行。</p>

<h2><span id="Comment Sentences">Comment Sentences</span></h2>

<p>查看<a href="https://golang.org/doc/effective_go.html#commentary">https://golang.org/doc/effective_go.html#commentary</a>，声明的注释应该占完整行，这样在将注释抽取到godoc文档时可以更好的格式化。注释应该以被注释声明开始，存在结束：</p>

<pre><code>// Request represents a request to run a command.
type Request struct { ...

// Encode writes the JSON encoding of req to w.
func Encode(w io.Writer, req *Request) { ...
</code></pre>

<h2><span id="Contexts">Contexts</span></h2>

<p><code>context.Context</code>类型实例在API和进程边界中传递安全证书、跟踪信息、超时期限和取消信号。Go程序在从RPC或者HTTP请求开始到输出请求的整个函数调用链过程中显示传递Context实例。  <br/>
大部分函数使用Context作为第一个参数：</p>

<pre><code>func F(ctx context.Context, /* other arguments */) {}
</code></pre>

<p>如果一个函数不是请求特化的话，可以使用context.Background，即使你觉得不必要也宁可传递一个Context实例。默认情况是传递一个Context上下文，除非有更好的理由来使用<code>context.Background</code>。<br/>
不要在结构体类型中添加<code>Context</code>成员，在结构体类型的所有需要使用Context的方法中添加一个ctx参数，用来传递Context。一个特殊情况是如果这些方法需要满足标准库或者第三方库中的接口。<br/>
不要在函数声明中使用特定Context类型或者使用非Context接口。<br/>
除非真的需要，否则通过参数，全局变量或者其他方法传递应用程序数据。<br/>
Context是不可变的，所以可在多个调用中传递同一个ctx共享同样的最后期限、取消信号、资格认证和跟踪等等。</p>

<h2><span id="Copying"> Copying</span></h2>

<p>避免非预期的别名使用，当从其他包拷贝结构体时需要小心。比如，bytes.Buffer类型包含一个<code>[]byte</code>数组，当保存的字符串比较小时，内部<code>[]byte</code>数组就比较小。如果拷贝一个<code>Buffer</code>，新旧Buffer类型变量中的数组就发生了混淆，这样接下来对于两个Buffer对象的使用将产生不可预知的情况。<br/>
总的来说，如果一个类型<code>T</code>，它的方法都与<code>*T</code>想对象，那就不要复制这个类型的变量。</p>

<h2><span id="Declaring Empty Slices"> Declaring Empty Slices</span></h2>

<p>声明一个空切片时，使用下面方式：</p>

<pre><code>var t []string
</code></pre>

<p>而不是</p>

<pre><code>t := []string{}
</code></pre>

<p>前者声明一个nil切片，后者定义一个长度为0的非nil切片。两种方式定义的切片<code>len</code>和<code>cap</code>的值都为0，建议使用前者。</p>

<p>一些场景下建议使用后者定义空切片，比如将对象序列化为JSON格式时，<code>nil</code>序列化为<code>null</code>，<code>[]string{}</code>序列化为<code>[]</code>。</p>

<p>设计接口时，避免nil切片，非nil切片和长度为0的切片产生差异，否则会产生微妙的错误。</p>

<p>更多关于Go中nil的讨论见：<a href="https://www.youtube.com/watch?v=ynoY2xz-F8s">Understanding Nil</a></p>

<h2><span id="Crypto Rand">Crypto Rand</span></h2>

<p>即使只使用一次，也不要使用<code>math/rand</code>生成key。没有种子，生成是可预测的。使用<code>time.Nanoseconds()</code>设置种子，只有一点熵。可替换方法是，使用<code>crypto/rand</code>，如果需要文本，打印为十六进制或者base64编码。</p>

<pre><code>import (
"crypto/rand"
// "encoding/base64"
// "encoding/hex"
"fmt"
)

func Key() string {
    buf := make([]byte, 16)
    _, err := rand.Read(buf)
if err != nil {
    panic(err)  // out of randomness, should never happen
}
return fmt.Sprintf("%x", buf)
// or hex.EncodeToString(buf)
// or base64.StdEncoding.EncodeToString(buf)    
}
</code></pre>

<h2><span id="Doc Comments">Doc Comments</span></h2>

<p>所有顶级，对外提供的名称应该有文档注释，一些重要的非对外提供的类型和函数定名也需要有注释。更多关于注释的信息参考：<a href="https://golang.org/doc/effective_go.html#commentary">https://golang.org/doc/effective_go.html#commentary</a></p>

<h2><span id="Don't Panic">Don&rsquo;t Panic</span></h2>

<p>关于错误处理参考：<a href="https://golang.org/doc/effective_go.html#errors">https://golang.org/doc/effective_go.html#errors</a>。不要使用<code>panic </code>处理普通错误。使用error和多返回值。</p>

<h2><span id="Error Strings">Error Strings</span></h2>

<p>错误字符串不应该大写，除非是以名词或者缩写开头，因为错误信息通常跟在其他信息后面。使用<code>fmt.Errorf("something bad")</code>，而不是<code>fmt.Errorf("Something bad")</code>，所以<code>log.Printf("Reading %s: %v", filename, err)</code>格式化的信息中不会在中间出现一个可以的大写字符。</p>

<h2><span id="Examples">Examples</span></h2>

<p>当添加一个新包时，包含使用示例：一个可运行示例，或者一个简单测试演示一个完整调用顺序。<br/>
更多信息参考：<a href="https://blog.golang.org/examples">testable Example() functions</a>。</p>

<h2><span id="Goroutine Lifetimes">Goroutine Lifetimes</span></h2>

<p>当创建goroutine时，需要对它是否退出和什么时间退出非常清楚。</p>

<p>goroutine阻塞在发送或者接收通道时可能会导致泄漏：垃圾收集不会结束这样的goroutine。</p>

<p>即使这些goroutine没有泄漏，这样的goroutine有可能导致微妙的不易定位的问题。向已经关闭的通道发送数据会导致panic。</p>

<p>保持并发执行的代码足够简单，这样goroutine的声明周期更明显。 如果不能这样的话，对goroutine的退出时机进行注释。</p>

<h2><span id="Handle Errors">Handle Errors</span></h2>

<p>查看错误处理<a href="https://golang.org/doc/effective_go.html#errors">https://golang.org/doc/effective_go.html#errors</a>，不要使用<code>_</code>丢弃错误。如果一个函数返回错误，对返回值进行检查。处理错误，返回。如果是异常情况，则panic。</p>

<h2><span id="Imports">Import</span></h2>

<p>除了避免命名冲突，不要重命名引入的包。好的包命名不需要重命名。万一出现冲突，优先考虑重命名本地包或者项目相关的引入。</p>

<p>引入的包成组组织，以空行分隔。标准库总是在第一组。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "hash/adler32"
</span><span class='line'>  "os"
</span><span class='line'>
</span><span class='line'>  "appengine/foo"
</span><span class='line'>  "appengine/user"
</span><span class='line'>
</span><span class='line'>  "code.google.com/p/x/y"
</span><span class='line'>  "github.com/foo/bar"
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a>工具会完成上面的格式化。</p>

<h2><span id="Import Dot">Import Dot</span></h2>

<p>进行测试时，因为循环依赖，不能将测试用例放入被测包中时，可以用<code>import .</code>解决：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package foo_test
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "bar/testutil" // also imports "foo"
</span><span class='line'>  . "foo"
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>这个例子中，测试文件不能放入<code>foo</code>包中，因为它使用<code>bar/testutil</code>，<code>bar/testutil</code>包引入了<code>foo</code>包。 我们使用<code>import .</code>使测试文件假装在包<code>foo</code>中，实际上不在。除了这一个特殊情况，不要使用<code>import .</code>。它使程序无法更好阅读，因为不方便区分一个大写开头的方法是当前包还是引入包中的顶级标识符。</p>

<h2><span id="In-Band Errors">In-Band Errors</span></h2>

<p>C或者其他类似语音中，函数返回-1或者null来表示错误是很常见的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Lookup returns the value for key or "" if there is no mapping for key.
</span><span class='line'>func Lookup(key string) string
</span><span class='line'>
</span><span class='line'>// Failing to check a for an in-band error value can lead to bugs:
</span><span class='line'>Parse(Lookup(key))  // returns "parse failure for value" instead of "no value for key"</span></code></pre></td></tr></table></div></figure>


<p>Go中的多返回值机制提供了一个更好的方案。函数直接放回一个错误值来表示函数执行结果是否正确。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Lookup returns the value for key or ok=false if there is no mapping for key.
</span><span class='line'>func Lookup(key string) (value string, ok bool)
</span></code></pre></td></tr></table></div></figure>


<p>这种格式可以阻止不正确的使用函数返回值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Lookup returns the value for key or ok=false if there is no mapping for key.
</span><span class='line'>func Lookup(key string) (value string, ok bool)</span></code></pre></td></tr></table></div></figure>


<p>一个更健壮和可阅读的风格如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>value, ok := Lookup(key)  
</span><span class='line'>if !ok  {  
</span><span class='line'>    return fmt.Errorf("no value for %q", key)
</span><span class='line'>}
</span><span class='line'>return Parse(value)</span></code></pre></td></tr></table></div></figure>


<p>这个规则对于导出函数和非导出函数都是有用的。</p>

<h2><span id="Indent Error Flow">Indent Error Flow</span></h2>

<p>保持正常流程最小缩进，缩进异常处理流程。这有助于提高可读性，可以快速查阅程序正常流程，不建议如下风格：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if err != nil {
</span><span class='line'>  // error handling
</span><span class='line'>} else {
</span><span class='line'>  // normal code
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>建议如下风格：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if err != nil {
</span><span class='line'>  // error handling
</span><span class='line'>  return // or continue, etc.
</span><span class='line'>}
</span><span class='line'>// normal code</span></code></pre></td></tr></table></div></figure>


<p>像下面这样<code>if</code>表达式中带初始化操作的语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if x, err := f(); err != nil {
</span><span class='line'>  // error handling
</span><span class='line'>  return
</span><span class='line'>} else {
</span><span class='line'>  // use x
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>建议将声明挪到外面去，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x, err := f()
</span><span class='line'>if err != nil {
</span><span class='line'>  // error handling
</span><span class='line'>  return
</span><span class='line'>}
</span><span class='line'>// use x</span></code></pre></td></tr></table></div></figure>


<h2><span id="Initialisms"> Initialisms</span></h2>

<p>命名中的首字母缩写应该保持同一大小写风格。比如，<code>URL</code>应该写为<code>URL</code>或者<code>url</code>（<code>URLPony</code>或者<code>urlPony</code>）,不应该为<code>Url</code>。又一个例子：应该为<code>ServeHTTP</code>而不应该为<code>ServeHttp</code>。<br/>
这个规则也适用于<code>identifier</code>的缩写<code>ID</code>，应该命名为<code>appID</code>而不是<code>appid</code>。<br/>
protocol buffer编译生成的代码可以不遵守这个规则。人类编写的程序应该比机器坚持更高标准。</p>

<h2><span id="Interfaces"> Interfaces</span></h2>

<p>Go 接口通常定义在使用接口的包中，而不是在实现接口的包中。实现的包应该返回具体类型（通常指针类型或者结构体）：这种方法，可以方便的在实现类型上增加新方法。</p>

<p>不要因为模拟，在具体实现这边定义接口类型。</p>

<p>不要在使用之前定义接口类型：没有使用的实际用例，对于判断一个接口是否需要是困难的，不要去想接口应该包含哪些方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package consumer  // consumer.go
</span><span class='line'>
</span><span class='line'>type Thinger interface { Thing() bool }
</span><span class='line'>
</span><span class='line'>func Foo(t Thinger) string { … }</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package consumer // consumer_test.go
</span><span class='line'>
</span><span class='line'>type fakeThinger struct{ … }
</span><span class='line'>func (t fakeThinger) Thing() bool { … }
</span><span class='line'>…
</span><span class='line'>if Foo(fakeThinger{…}) == "x" { … }</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// DO NOT DO IT!!!
</span><span class='line'>package producer
</span><span class='line'>
</span><span class='line'>type Thinger interface { Thing() bool }
</span><span class='line'>
</span><span class='line'>type defaultThinger struct{ … }
</span><span class='line'>func (t defaultThinger) Thing() bool { … }
</span><span class='line'>
</span><span class='line'>func NewThinger() Thinger { return defaultThinger{ … } }</span></code></pre></td></tr></table></div></figure>


<p>定义一个具体类型，让消费者模拟生产者实现。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package producer
</span><span class='line'>
</span><span class='line'>type Thinger struct{ … }
</span><span class='line'>func (t Thinger) Thing() bool { … }
</span><span class='line'>
</span><span class='line'>func NewThinger() Thinger { return Thinger{ … } }
</span></code></pre></td></tr></table></div></figure>


<h2><span id="Mixed Caps"> Mixed Caps</span></h2>

<p>查看<a href="https://golang.org/doc/effective_go.html#mixed-caps">mixed-caps</a>，这打破了其他语言中惯例。比如一个非导出常量命名<code>maxLength</code>而不是<code>MaxLength</code>和<code>MAX_LENGTH</code>。</p>

<h2><span id="Named Result Parameters"> Named Result Parameters</span></h2>

<p>下面这样的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func (n *Node) Parent1() (node *Node)
</span><span class='line'>func (n *Node) Parent2() (node *Node, err error)</span></code></pre></td></tr></table></div></figure>


<p>最好定义成如下方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func (n *Node) Parent1() *Node
</span><span class='line'>func (n *Node) Parent2() (*Node, error)</span></code></pre></td></tr></table></div></figure>


<p>其他情况，如果一个函数返回两个或者三个相同类型的值，或者一个返回值的意义不是很明确，那么应该给返回值命名。</p>

<pre><code>func (f *Foo) Location() (float64, float64, error)
</code></pre>

<p>没有下面命名更清晰：</p>

<pre><code>// Location returns f's latitude and longitude.
// Negative values mean south and west, respectively.
func (f *Foo) Location() (lat, long float64, err error)
</code></pre>

<h2><span id="Package Comments"> Package Comments</span></h2>

<p>包注释，与其他被godoc工具展示的注释类似，必须紧邻着package语句，不需要空白行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Package math provides basic constants and mathematical functions.  
</span><span class='line'>package math</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'>Package template implements data-driven templates for generating textual
</span><span class='line'>output such as HTML.
</span><span class='line'>....
</span><span class='line'>*/
</span><span class='line'>package template</span></code></pre></td></tr></table></div></figure>


<p>对于<code>package main</code>可以使用一些其他风格的注释，比如，在<code>seedgen</code>目录中的<code>package main</code>包，可以采用如下注释：</p>

<pre><code>// Binary seedgen ...
package main
</code></pre>

<p>或者</p>

<pre><code>// Command seedgen ...
package main
</code></pre>

<p>或者</p>

<pre><code>// Program seedgen ...
package main
</code></pre>

<p>或者</p>

<pre><code>// The seedgen command ...
package main
</code></pre>

<p>或者
    // The seedgen program &hellip;
    package main</p>

<p>或者</p>

<pre><code>// Seedgen ..
package main
</code></pre>

<p>上面例子的其他形式也是可以接受的。<br/>
对于包注释，不应该以小写字母开头，因为这些注释会被公开查看，应该按照英语规则书写。
查看<a href="https://golang.org/doc/effective_go.html#commentary">https://golang.org/doc/effective_go.html#commentary</a>关于注释的详细说明。</p>

<h2><span id="Package Names"> Package Names</span></h2>

<p>外界需要使用报名来引用包中的命名，所以可以在命名中将包名去掉。比如，如果<code>package chubby</code>中定义<code>File</code>，不需要定义成<code>ChubbyFile</code>，因为访问时就是这样<code>chubby.ChubbyFile</code>。直接定义成<code>File</code>，这样访问时就会是<code>chubby.File</code>。避免无意义包名，如<code>util, common,misc,api,types,interfaces</code>。查看<a href="http://golang.org/doc/effective_go.html#package-names">http://golang.org/doc/effective_go.html#package-names</a>和<a href="http://blog.golang.org/package-names">http://blog.golang.org/package-names</a>详细信息。</p>

<h2><span id="Pass Values"> Pass Values</span></h2>

<p>不要只是为了节省几个字节而传递指针作为函数地址。如果一个函数都是以<code>*x</code>的形式使用参数<code>x</code>，那么就参数<code>x</code>就不应该是指针形式。比如以传递一个字符串的指针<code>*string</code>或者一个指向接口的类型<code>*io.Reader</code>作为函数参数，在这两种场景中，字符串和接口类型值都是固定大小，可以直接传递。这个建议对于大的结构体类型并不适用。</p>

<h2><span id="Receiver Names"> Receiver Names</span></h2>

<p>方法接受者名称应该反映它的实体类型。通常是类型的一个或者两个字母缩写（比如用c和cl代表Client）。不要使用<code>me</code>，<code>this</code>或者<code>self</code>这样的面向对象语言中使用的标识符。</p>

<h2><span id="Receiver Type"> Receiver Type</span></h2>

<p>对于Go新手来说，定义方法时使用值还是指针作为接收者是困难的。如果有所疑虑，使用指针。下面是一些指导意见：</p>

<ul>
<li>如果接受者是<code>map``func</code>或者<code>chan</code>时，不要使用指针。如果接受者是一个<code>slice</code>并且方法中并没有重新分配slice，不要使用指针。</li>
<li>如果方法需要修改接受者，必须使用指针。</li>
<li>如果接受者是一个结构体并且包含sync.Mutex或者类似同步元语字段，接受者必须是指针类型避免拷贝。</li>
<li>如果接受者是一个大的结构体或者数组，指针类型接受者更有效率。</li>
</ul>


<h2><span id="Synchronous Functions"> Synchronous Functions</span></h2>

<h2>参考</h2>

<ul>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-names">CodeReviewComments</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 工程代码结构]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/06/11/golang-gong-cheng-dai-ma-jie-gou/"/>
    <updated>2017-06-11T12:19:45+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/06/11/golang-gong-cheng-dai-ma-jie-gou</id>
    <content type="html"><![CDATA[<p>golang工程常用代码目录结构</p>

<pre><code>github.com/user/project
    pkg
        p1
            *.go
        p2
            *.go 
    cmd
        cmdline
            main.go
    web
            main.go
    vendor
        github/*/*
    examples
    docs
</code></pre>

<h2>参考</h2>

<ul>
<li><p><a href="https://stackoverflow.com/questions/32634837/project-structure-for-a-tool-with-multiple-uis/32635264#32635264">Project structure for a tool with multiple UIs</a></p></li>
<li><p><a href="https://forum.golangbridge.org/t/how-should-i-structure-packages-for-a-multiple-binary-web-application/665">How should I structure packages for a multiple-binary web application?</a></p></li>
<li><a href="https://github.com/seccom/kpass">kpass</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Test命令详解]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/05/29/go-testming-ling-xiang-jie/"/>
    <updated>2017-05-29T10:58:11+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/05/29/go-testming-ling-xiang-jie</id>
    <content type="html"><![CDATA[<h2>Test packages</h2>

<p>使用：</p>

<pre><code>go test [build/test flags] [packages] [build/test flags &amp; test binary flags]
</code></pre>

<p><code>Go test</code>命令自动测试<code>packages</code>参数指定的包。它以如下格式打印测试结果摘要信息：</p>

<pre><code>ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
...
</code></pre>

<p><code>Go test</code>重新编译每个包中文件名为<code>*_test.go</code>模式的文件，将这些文件与测试库进行链接、运行。<br/>
go tool工具会忽略名为<code>testdata</code>的文件夹，使用这个文件夹来保存test中需要的数据。<br/>
默认情况，<code>go tes</code>不需要任何参数。它会编译并当前目录下所有test文件。  <br/>
测试包被安装在临时目录，所以它不会涉及到非测试包安装目录。<br/>
除了build标志，<code>go test</code>自身支持的标志如下：</p>

<pre><code>-args
    将-args后面的参数不做任何修改和解释的传递给test可执行文件。  
    需要在这个参数之前指定包名。  
-c 
    编译test二进制文件为pkg.test但是不运行。pkg为引入包路径的最后一层。
    可以使用-o参数修改可执行文件名。  
-exec xprog
    使用xprog运行test二进制文件。行为表现与go run一样。详情参照go help run  
-i 
    安装测试依赖的包。但是不运行测试。  
-o file
    指定可执行测试文件名并运行测试。  
</code></pre>

<p>test二进制可执行文件接受参数来控制test执行。这些参数也可以在<code>go test</code>使用：</p>

<pre><code>-bench regexp
    运行负荷正则表达式的子性能测试。
-benchmem
    性能测试中的内存统计信息。  
-benchtime t
    运行足够多的性能测试用例次数，使测试时间达到t，t的类型为time.Duration(比如，-benchtime 1h30s)。默认是1秒。    
-blockprofile block.out  
    所有测试结束后，将goroutine blocking 性能数据写入指定文件。  
-blockprofilerate n  
    使用runtime.SetBlockProfileRate控制goroutine blocking性能数据格式。  
-count n  
    运行每个测试用例和性能测试用例n次。如果设置了-cpu参数，每个GOMAXPROCS运行n次。  
-cover 
    启动覆盖率分析  
-covermode set,count,atomic
    设置覆盖分析模式。如果设置了-race，则覆盖分析模式为atomic，否则为默认set模式。
    set：
    count：
    atomic：
-coverpkg pkg1,pkg2,pkg3
    每个测试中都对给定列表中的包进行覆盖分析。默认是对正在进行测试的包进行分析。
-coverprofile cover.out
    所有测试都通过后，输出一个覆盖测试文件。  
-cpu 1,2,4  
    指定一个GOMAXPROCS列表，默认是GOMAXPROCS当前值。  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译]SOCKS5 协议]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/04/02/socks5-xie-yi/"/>
    <updated>2017-04-02T16:38:00+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/04/02/socks5-xie-yi</id>
    <content type="html"><![CDATA[<h2>介绍</h2>

<p>网络防火墙用来隔离组织内部网络和外部网络，比如<code>INTERNET</code>。这些防火墙系统扮演着内外部网络之间的应用层网关，用来控制<code>TELNET</code>、<code>FTP</code>和<code>SMTP</code>等协议的进入。随着更多复杂应用层协议被设计用来加速全局信息发现，需要为这些协议提供一个框架以便透明和安全的通过防火墙。 也需要提供为这种通过提供可靠授权。 <br/>
<code>SOCKS5</code>协议被设计用来为基于TCP或者UDP协议的client-server模式应用程序方便且安全的使用网络防火墙服务。这个协议概念上认为是在应用层和传输层之间，因此它不提供网络层网关服务，比如转发<code>ICMP</code>消息。</p>

<p>已经存在了一个<code>SOCKS4</code>协议，这个版本的协议在4版本的基础上支持UDP协议，包含通用授权范型和支持域名和V6版本IP地址。</p>

<!-- more -->


<h2>TCP客户端处理步骤</h2>

<p>当一个基于TCP协议的客户端希望与位于防火墙后面的目标之间建立一个连接时，它必须打开一个到<code>SOCKS</code>服务端的连接。<code>SOCKS</code>服务按照惯例位于1080TCP端口。 如果连接建立成功后，客户端发送鉴权请求。服务端评估请求，要么建立相应连接或者拒绝这个请求。  <br/>
客户端连接socks服务端，发送一个版本标识符或者方法选择消息：</p>

<pre><code>+----+----------+----------+
|VER | NMETHODS | METHODS  |
+----+----------+----------+
| 1  |    1     | 1 to 255 |
+----+----------+----------+
</code></pre>

<p><code>VER</code>字段设置为<code>X'05'</code>是这个协议的版本。<code>NMETHODS</code>字段包含出现在<code>METHODS</code>字段中的值的字节数。<br/>
socks服务端从<code>METHODS</code>中选择一个方法，发送一个<code>METHOD</code>选择消息：</p>

<pre><code>+----+--------+
|VER | METHOD |
+----+--------+
| 1  |   1    |
+----+--------+
</code></pre>

<p>如果选择的<code>METHOD</code>为<code>X'FF'</code>，那么客户端列出的所有方法都不被接受，这时候客户端必须关闭连接。<br/>
目前定义的<code>METHOD</code>值有：</p>

<pre><code>o  X'00' NO AUTHENTICATION REQUIRED
o  X'01' GSSAPI
o  X'02' USERNAME/PASSWORD
o  X'03' to X'7F' IANA ASSIGNED
o  X'80' to X'FE' RESERVED FOR PRIVATE METHODS
o  X'FF' NO ACCEPTABLE METHODS  
</code></pre>

<p>方法选择之后，客户端和服务端之间进入与方法相关的子协商。</p>

<h2>请求</h2>

<p>子协商完成后，客户端发送请求详情。如果协商结果是需要对发送的消息进行封装加密，那么请求消息必须进行封装加密。<br/>
SOCKS协议请求格式为：</p>

<pre><code>+----+-----+-------+------+----------+----------+
|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  | X'00' |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+
</code></pre>

<p>字段说明如下：</p>

<pre><code>o  VER    protocol version: X'05'
o  CMD
o  CONNECT X'01'
o  BIND X'02'
o  UDP ASSOCIATE X'03'
o  RSV    RESERVED
o  ATYP   address type of following address
o  IP V4 address: X'01'
o  DOMAINNAME: X'03'
o  IP V6 address: X'04'
o  DST.ADDR       desired destination address
o  DST.PORT desired destination port in network octet order
</code></pre>

<p>SOCKS服务端将会根据源和目的地址评估请求，并且根据请求类型返回一个或者多个回复消息。</p>

<h2>地址</h2>

<p>在地址字段（<code>DST.ADDR BND.ADDR</code>），<code>ATYP</code>字段指示了地址的类型：</p>

<ul>
<li>X&#8217;01&#8217;
指示地址为IPv4地址，长度为4个字节。</li>
<li>X&#8217;03&#8217;
指示地址为域名。地址的第一个字节为域名的长度，域名不是以<code>NUL</code>结束的。</li>
<li>X&#8217;04&#8217;
地址为IPv6地址，长度为16个字节。</li>
</ul>


<h2>回复</h2>

<p>对应上面的请求，服务端回复以下应答：</p>

<pre><code>+----+-----+-------+------+----------+----------+
|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  | X'00' |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+ 
</code></pre>

<p> 字段说明如下：</p>

<pre><code> o  VER    protocol version: X'05'
 o  REP    Reply field:
    o  X'00' succeeded
    o  X'01' general SOCKS server failure
    o  X'02' connection not allowed by ruleset
    o  X'03' Network unreachable
    o  X'04' Host unreachable
    o  X'05' Connection refused
    o  X'06' TTL expired
    o  X'07' Command not supported
    o  X'08' Address type not supported
    o  X'09' to X'FF' unassigned

 o  RSV    RESERVED
 o  ATYP   address type of following address
     o  IP V4 address: X'01'
     o  DOMAINNAME: X'03'
     o  IP V6 address: X'04'
 o  BND.ADDR       server bound address
 o  BND.PORT       server bound port in network octet order
</code></pre>

<p>标记为<code>RESERVED</code>的字段必须设置为X&#8217;00&#8217;</p>

<h3>CONNECT</h3>

<p>对于<code>CONNECT</code>请求消息的应答中，<code>BND.PORT</code>字段为服务端绑定的用来连接到目标主机的端口号，<code>BND.ADDR</code>字段为绑定的地址。绑定的地址通常与客户端连接服务端的地址不同。</p>

<h3>BIND</h3>

<p>BIND请求被用来要求客户端接受来自服务端的请求。FTP是一个常见的例子，它使用客户端到服务端的连接发送命令和状态，使用服务端到客户端的连接传输数据。  <br/>
客户端使用<code>CONNECT</code>建立主连接，使用<code>BIND</code>请求只是用来建立第二个连接。<br/>
对于<code>BIND</code>请求，<code>SOCKS</code>服务端将使用<code>DST.ADDR</code>和<code>DST.PORT</code>。<br/>
对于<code>BIND</code>操作，SOCKS服务端将会发送两个回复到客户端。服务端创建和绑定一个新的socket套接字后发送第一个回复。回复中<code>BND.PORT</code>字段值为SOCKS服务端本地绑定用来监听和接受连接的端口号。<code>BND.ADDR</code>字段为SOCKS服务端绑定的IP。客户端通过主控制链路发送这些信息给应用程序服务端。当新的连接建立成功或者失败后，SOCKS服务端会发送第二个应答。 在第二个应答中，<code>BND.PORT</code>和<code>BND.ADDR</code>字段包含连接主机的ip和端口信息。</p>

<h3>UDP</h3>

<p><code>UDP ASSOCIATE</code>请求用来与UDP中继进程建立一个联系来处理UDP数据报。客户端希望发送UDP数据报到<code>DST.ADDR</code>和<code>DST.PORT</code>字段标示的IP和端口号。在建立UDP ASSOCIATE时，如果客户端不拥有这些信息，客户端必须使用全零的端口号和ip地址。  <br/>
当发送UDP ASSOCIATE请求的TCP连接中断时，这个UDP 连接也要中断。<br/>
在对UDP ASSOCIATE请求的应答中，<code>BND.PORT</code>和<code>BND.ADDR</code>字段表示客户端必须将待转发的UDP消息发送到这个地址。</p>

<h3>应答处理</h3>

<p>如果应答消息中结果字段为失败，SOCKS服务端必须在发送应答后立即关闭TCP连接。关闭连接必须在检测到失败后10秒内终止连接。</p>

<p>如果应答消息中结果字段为成功，请求为<code>BIND</code>或者<code>CONNECT</code>的话，客户端就可以开始传输数据。 如果协商了封装加密方法的话，在客户端和SOCKS服务端通信过程中需要进行封装加密。</p>

<h2>UDP客户端</h2>

<p>udp客户端必须想UDP ASSOCIATE应答中<code>BND.PORT</code>标示的字段发送UDP数据报。如果协商了封装方法，那么通讯时需要进行封装。<br/>
每个UDP数据需要携带一个UDP请求头：</p>

<pre><code>+----+------+------+----------+----------+----------+
|RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
+----+------+------+----------+----------+----------+
| 2  |  1   |  1   | Variable |    2     | Variable |
+----+------+------+----------+----------+----------+
</code></pre>

<p> 字段说明如下：</p>

<pre><code> o  RSV  Reserved X'0000'
 o  FRAG    Current fragment number
 o  ATYP    address type of following addresses:
        o  IP V4 address: X'01'
      o  DOMAINNAME: X'03'
      o  IP V6 address: X'04'
 o  DST.ADDR       desired destination address
 o  DST.PORT       desired destination port
 o  DATA     user data
</code></pre>

<p>UDP中继服务端必须从SOCKS服务端获取申请建立UDP ASSOCIATE的客户端ip地址。中继服务端对于其他源ip发送过来的数据包将会丢弃。</p>

<h2>参考</h2>

<p><a href="https://www.ietf.org/rfc/rfc1928.txt">rfc1928</a><br/>
<a href="https://tools.ietf.org/html/rfc1929">rfc1929</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH常用设置(免密、别名登录、隧道转发)]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/03/30/sshsui-dao-zhuan-fa-gong-neng/"/>
    <updated>2017-03-30T19:48:56+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/03/30/sshsui-dao-zhuan-fa-gong-neng</id>
    <content type="html"><![CDATA[<p>作为程序员每天都需要使用ssh登录到远程主机进行部署调试，本篇将总结ssh工具几个常用方法：</p>

<ul>
<li><a href="#password-less">免密登录</a></li>
<li><a href="#alias">别名登录</a></li>
<li><a href="#tunnel">隧道转发</a></li>
</ul>


<h2><a name="password-less"> </a>免密登录</h2>

<ol>
<li>在本地机器上生成pubkey</li>
<li>将pubkey拷贝到远程主机~/.ssh/authorized_keys文件中</li>
</ol>


<h2><a name="alias"/> </a>别名登录</h2>

<p>在免密登录的基础上， 可以方便实现别名登录
在本地~/.ssh/config文件中配置远程主机相关信息：</p>

<pre><code>Host vps
    HostName 45.78.61.64
    Port 22
    User root
</code></pre>

<p> 本地可以使用</p>

<pre><code>ssh vps
</code></pre>

<p> 这样的形式直接登录目标主机</p>

<h2><a name="tunnel"> </a> 隧道转发</h2>

<p>远端主机可能设置了防火墙，只开放少数端口，比如远端机器只开放了22 ssh端口，如果本地想连接远端3306端口的话，会被防火墙拒绝，这个时候我们可以利用ssh的隧道功能，将本地流量通过ssh tunnel转发远端目标端口，在~/.ssh/config配置文件中添加如下配置：</p>

<pre><code>Host tunnel
    HostName 45.78.61.64
    Port 27764
    LocalForward 3306 127.0.0.1:3306
    User root
</code></pre>

<p> 上面的意思是将本地3306端口流量隧道转发到45.78.61.64 3306端口
    添加配置后，需要运行下面命令：</p>

<pre><code>ssh -f -N tunnel 
</code></pre>

<p>使用lsof -i:3306我们可以看到ssh程序正在监听这个端口，当有数据从这个端口进来时，ssh程序会将数据转发到远端sshd服务端程序，服务端程序会将流量转发到远端本地3306端口，ssh隧道数据是加密的，我上一篇开发的<a href="http://jintao-zero.github.io/blog/2017/03/29/golang-shi-xian-httpdai-li/">http proxy</a>我们可以利用ssh可以利用这个功能躲避GFW</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 实现HTTP代理]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/03/29/golang-shi-xian-httpdai-li/"/>
    <updated>2017-03-29T16:51:16+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/03/29/golang-shi-xian-httpdai-li</id>
    <content type="html"><![CDATA[<p>使用Golang实现一个HTTP代理程序，程序部署在海外VPS节点，可以实现翻墙功能<br/>
HTTP Proxy的基本原理是将客户端HTTP请求发送到目标主机，将目标主机返回的HTTP应答转发到客户端,对于HTTPS协议略有不同，HTTPS协议需要Proxy先建立一条到目标主机的链路，之后再进行协议本身的通讯，下面简单介绍一个HTTP Proxy的实现过程：</p>

<h3>分析第一条请求</h3>

<ol>
<li><p>启动一个简版HTTP Proxy程序，代码如下：</p>

<pre><code> func handleConn(conn net.Conn) {
     defer conn.Close()
     log.Println("client conn form ", conn.RemoteAddr())
     var buffer [1024]byte
     _, err := conn.Read(buffer[:])
     if err != nil {
         return
     }
     log.Println(string(buffer[:]))
 }

 func main() {
     // listen on tcp port
     l, err := net.Listen("tcp", ":8081")
     if err != nil {
         log.Println(err)
         return
     }
     for {
         conn, err := l.Accept()
         if err != nil {
             log.Println(err)
             return
         }
         go handleConn(conn)
     }
 }  
 go run httpproxy.go
</code></pre>

<p> 这个程序主要是用来接收客户端发送的第一条HTTP请求</p></li>
</ol>


<!-- more -->


<ol>
<li><p>Safari设置HTTP/HTTPS代理<br/>
 设置代理为<code>localhost:8081</code><br/>
 <img src="http://jintao-zero.github.io/images/http-proxy-1.png" alt="proxy" /></p></li>
<li><p>Safari输入框访问<code>http://localhost:8080</code>，我们的proxy程序输出HTTP请求：</p>

<pre><code> GET http://www.localhost.com:8080/ HTTP/1.1
 Host: www.localhost.com:8080
 Proxy-Connection: keep-alive
 Upgrade-Insecure-Requests: 1
 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/602.4.8 (KHTML, like Gecko)     Version/10.0.3 Safari/602.4.8
 Accept-Language: zh-cn
 Accept-Encoding: gzip, deflate
 Connection: keep-alive
</code></pre>

<p>其中跟代理有关的是前两行：</p>

<pre><code>  GET http://www.localhost.com:8080/ HTTP/1.1
  Host: www.localhost.com:8080
</code></pre>

<p>当访问<code>http://localhost</code>时，输出的前两行为：</p>

<pre><code>  GET http://www.localhost.com/ HTTP/1.1
  Host: www.localhost.com
</code></pre></li>
<li><p>Safari输入框访问<code>https://localhost:8080</code>时，proxy程序输出HTTP请求为：</p>

<pre><code> CONNECT www.localhost.com:8080 HTTP/1.1
 Host: www.localhost.com:8080
 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/602.4.8 (KHTML, like Gecko) Version/10.0.3 Safari/602.4.8
 Connection: keep-alive
 Proxy-Connection: keep-alive
</code></pre>

<p>访问网址为<code>https://localhost</code>时，输出为：</p>

<pre><code> CONNECT www.localhost.com:443 HTTP/1.1
 Host: www.localhost.com
 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/602.4.8 (KHTML, like Gecko) Version/10.0.3 Safari/602.4.8
 Connection: keep-alive
 Proxy-Connection: keep-alive
</code></pre></li>
</ol>


<p>设置代理后，客户端发送HTTP请求之前需要先与Proxy通讯建立到目标主机的通讯隧道，命令消息格式为：</p>

<pre><code>method absoluteURI HTTP/1.1
</code></pre>

<p>使用<code>HTTP</code>协议时，使用<code>GET</code>命令发送请求，使用<code>HTTPS</code>协议时，使用<code>CONNECT</code>命令发送请求,后面跟着<a href="http://greenbytes.de/tech/webdav/rfc2616.html#general.syntax">absoluteURI</a>,再就是HTTP版本信息
第二行为<code>Host</code>头标示了需要访问的目标地址，根据<a href="[Request-URI](http://greenbytes.de/tech/webdav/rfc2616.html#request-uri"><code>HTTP/1.1</code></a>)版本规定，客户端和服务的必须支持<code>Host</code>头，但是默认协议情况下，host头只包含域名，不包含默认端口号(<code>HTTP(80)``HTTPS(443)</code>)</p>

<p>我们的proxy程序需要根据<code>absoluteURI</code>获取目标域名和端口，从而建立到目标主机的连接，示例代码如下：</p>

<pre><code>var buffer [1024]byte
n, err := conn.Read(buffer[:])
if err != nil {
    return
}
log.Println(string(buffer[:]))
_, line, err := bufio.ScanLines(buffer[:], true)
if err != nil {
    log.Println(err)
    return
}
var method string
var absUri string
_, err = fmt.Sscanf(string(line), "%s%s", &amp;method, &amp;absUri)
if err != nil {
    log.Println(err)
    return
}
absUrl, err := url.Parse(absUri)
if err != nil {
    log.Println(err)
    return
}
log.Printf("%+v", *absUrl)
var hostPort string
if absUrl.Scheme == "http" {
    if strings.Index(absUrl.Host, ":") == -1 {
        hostPort = absUrl.Host + ":80"
    } else {
        hostPort = absUrl.Host
    }
} else {
    hostPort = absUrl.Scheme + ":" + absUrl.Opaque
}
log.Println("hostPort", hostPort)
</code></pre>

<h3>建立连接</h3>

<ol>
<li>根据获取的目标地址+端口建立到目标主机的tcp连接</li>
<li><p>根据第一条请求的协议类型(HTTP/HTTPS),做不同应答处理：<br/>
 2.1 HTTP消息，直接转发给目标主机，不对客户端有应答<br/>
 2.2 HTTPS CONNECT消息，对客户端应答<code>200</code>消息：</p>

<pre><code> HTTP/1.1 200 Connection established\r\n\r\n
</code></pre></li>
<li><p>不间断进行消息转发，某一方连接异常后，关闭双方连接</p>

<pre><code> go io.Copy(conn, serverConn)
 io.Copy(serverConn, conn)
</code></pre></li>
</ol>


<h3>部署</h3>

<ol>
<li><a href="https://github.com/jintao-zero/golang-http-proxy">完整代码</a></li>
<li>编译生成二进制可执行文件，部署到海外VPS服务器，浏览器设置对应ip和端口后，即可翻墙</li>
</ol>


<h3>遗留问题</h3>

<p>1、转发功能基本实现，但是依然无法访问google、facebook等被GFW墙的网站
    我猜想是明文HTTP请求中<code>google、facebook</code>类的网站名被匹配到，出口连接被关闭，使用了ssh tunnel功能，将数据加密传输解决了这个问题</p>

<h3>参考</h3>

<ol>
<li><a href="http://greenbytes.de/tech/webdav/rfc2616.html#changes.from.1.0">HTTP1.0 VS HTTP1.1</a></li>
<li><a href="http://stackoverflow.com/questions/7155529/how-does-http-proxy-work">how does http proxy work?</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proxy_server#Web_proxy_servers">Proxy server</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protocol-buffers Proto3 翻译]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/03/12/protocol-buffers-proto3-fan-yi/"/>
    <updated>2017-03-12T18:09:36+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/03/12/protocol-buffers-proto3-fan-yi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#message">定义Message类型</a></li>
<li><a href="#type">标量值类型</a></li>
<li><a href="#default">默认值</a></li>
<li><a href="#enum">枚举</a></li>
<li><a href="#other_message">使用其他消息类型</a></li>
<li><a href="#nested">嵌套类型</a></li>
<li><a href="#update">更新消息类型</a></li>
<li><a href="#unknown">未知字段</a></li>
<li><a href="#any">Any</a></li>
<li><a href="#oneof">Oneof</a></li>
<li><a href="#maps">Maps</a></li>
<li><a href="#packages">包</a></li>
<li><a href="#services">服务</a></li>
<li><a href="#json">json</a></li>
<li><a href="#options">选项</a></li>
<li><a href="#protoc">生成代码</a></li>
</ul>


<p>这个指导文档如何使用protocol buffer语言结构化你的protocol buffer数据，包括<code>.proto</code>文件语法和如何根据<code>.proto</code>文件生成代码访问数据。本文主要描述<code>proto3</code>版本。  <br/>
本文是参考文档，如果需要例子的话可以访问，你选择语言相关的<a href="https://developers.google.com/protocol-buffers/docs/tutorials">入门指导</a></p>

<h2><a name="message"></a>Message定义</h2>

<p>一个简单例子。下面定义一个搜索请求消息格式，这个消息包含一个查询字符串，包含一个搜索结果页码，和每页包含搜索结果数。下面是该消息<code>.proto</code>文件：</p>

<pre><code>syntax = "proto3";

message SearchRequest {
    string query = 1;
    int32 page_number = 2;
    int32 result_per_page = 3;
}
</code></pre>

<ul>
<li>第一行说明正在使用<code>proto3</code>语法：如果不指定proto版本，protocol buffer编译器默认认为正在使用<code>proto2</code>。这行语句必须是第一条非空、非注释语句。</li>
<li><code>SearchRequest</code>消息包含三个字段。每个字段有都有一个名字和类型。</li>
</ul>


<!-- more -->


<h3>字段类型</h3>

<p>在上面的例子中，所有字段都是标量类型：两个整型（<code>page_number</code>和<code>result_per_page</code>）和字符串（<code>query</code>）。你也可以指定字段类型为组合类型，包含枚举或者其他类型。</p>

<h3>添加Tag标签</h3>

<p>如定义所见，每一个字段都有一个唯一的数字标签。这些标签用来在<a href="https://developers.google.com/protocol-buffers/docs/encoding">消息二进制格式</a>中标示相应字段，一旦消息类型得到使用，就不应该在修改字段标签。值在1到15之间的tag编码时只占用一个字节，一个字节包含了tag值和字段类型，更多信息可以参考<a href="https://developers.google.com/protocol-buffers/docs/encoding.html#structure">Protocol Buffer Encoding</a>。16到2047之间的标签占用两个字节。所以应该用1到15之间的标签标示经常使用的字段，并且给未来可能添加进来的频繁使用字段预留一些标签。</p>

<p>自小标签值为1，最大值为2的29次方-1，即536,870,911。tag值区间19000到19999（FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber）是<code>Protocol Buffers</code>的保留值，如果在<code>.proto</code>文件中使用了这个范围内的值，编译器将会报警。</p>

<h3>指定字段规则</h3>

<p>消息类型可以为如下类型：</p>

<ul>
<li>单数形式： 一个正确格式的消息可以包含0个或者一个这样的字段（不能大于一个）</li>
<li>重复类型： 这种类型的字段可以在一个消息中重复多次（包括0次）。</li>
</ul>


<p><code>proto3</code>中，标量类型的<code>repeated</code>字段类型默认使用<code>packed</code>编码。</p>

<p>可以在<a href="Protocol%20Buffer%20Encoding">Protocol Buffer Encoding</a>查看关于编码的详细内容。</p>

<h3>添加更多Message类型</h3>

<p>一个<code>.proto</code>文件中可以定义多个消息类型。因此可以将相关消息类型定义在一个<code>.proto</code>文件中，比如可以在上面的proto文件添加一个<code>SearchResponse</code>消息类型：</p>

<pre><code>message SearchRequest {
    string query = 1;
    int32 page_number = 2;
    int32 result_per_page = 3;
}

message SearchResponse {
    ...
}
</code></pre>

<h3>添加注释</h3>

<p><code>.proto</code>文件中，使用C/C++风格<code>//</code>注释</p>

<pre><code>message SearchRequest {
    string query = 1;
    int32 page_number = 2;  // Which page number do we want?
    int32 result_per_page = 3;  // Number of results to return per page.
}
</code></pre>

<h3>保留字段</h3>

<p>当完整删除一个字段，或者注释掉字段，这种方式修改一个消息类型时，未来用户可能会复用之前的标签值。如果加载就版本<code>.proto</code>文件时，这种情况可能会引起数据冲突，程序问题或者其他异常情况。可以通过将已经删除字段的tag值或者字段名设置为<code>reserved</code>。如果将来有人用到这些保留值，编译器将会报错。</p>

<pre><code>message Foo {
    reserved 2, 15, 9 to 11;
    reserved "foo", "bar";
}
</code></pre>

<p>注意不可以在同一个<code>reserved</code>语句中同时标示tag和字段</p>

<h3>从.proto文件生成什么</h3>

<p>当用编译器处理已经编写好的<code>.proto</code>文件时，编译器会根据选择的编程语言类型生成代码，使用这些代码可以操作<code>.proto</code>文件中定义的消息类型，包括获取、设置字段值，序列化消息到输出流，从输入流中反序列化消息。</p>

<ul>
<li>C++，编译器为每个<code>.proto</code>文件生成一个<code>.h</code>和<code>.cc</code>文件，对于文件中定义的每个消息类型生成一个类</li>
<li>Java,编译器为每个消息类型生成一个<code>.java</code>文件，同时生成一个<code>Builder</code>类用于创建消息类实例</li>
<li>Python，编译器为每个消息类型生成一个包含静态描述符的模块，在python运行时，可以与原类型一起生成一个Python数据存取类</li>
<li>Go，编译器为<code>.proto</code>文件中的每个消息类型生成一个<code>.pb.go</code>文件</li>
<li>Ruby，编译器生成一个<code>.rb</code>文件包含一个ruby模块包括所有文件中国年定义的消息类型</li>
<li>JavaNano，编译器生成的内容与Java类似，但是没有<code>Builder</code>类型。</li>
<li>Objective-C，编译器为每一个<code>.proto</code>文件生成一个<code>pbobjc.h</code>和<code>pbobjc.m</code>文件，为每个消息类型生成一个类。</li>
<li>C#，编译器生成一个<code>.cs</code>文件，每个消息类型生成一个类。</li>
</ul>


<p>可以从<a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference</a>中了解更多API相关信息</p>

<h2><a name="type"></a>标量值类型</h2>

<p>一个标量消息字段可以用如下消息类型，这些类型可以使用在<code>.proto</code>文件中，表中列出了相应语言的数据类型：</p>

<p><img src="http://jintao-zero.github.io/images/proto-1.png" alt="" />
<img src="http://jintao-zero.github.io/images/proto-2.png" alt="" />
<img src="http://jintao-zero.github.io/images/proto-3.png" alt="" />
<img src="http://jintao-zero.github.io/images/proto-4.png" alt="" />
<img src="http://jintao-zero.github.io/images/proto-5.png" alt="" /></p>

<p>可以在<a href="https://developers.google.com/protocol-buffers/docs/encoding">Protocol Buffer Encoding</a>中查看上面类型如何编码。</p>

<h2><a name="default"></a>默认值</h2>

<p>解析消息时，如果编码消息没有包含某个元素值，那么消息对象中对应字段的值设置为字段类型的默认值。不同类型具有不同默认值：</p>

<ul>
<li>字符串类型，默认为空字符串</li>
<li>字节类型，默认为空字节</li>
<li>布尔型，默认为false</li>
<li>数字类型，默认为0</li>
<li>枚举类型，默认为枚举类型第一个值，这个值必须为0</li>
<li>message类型，字段不进行设置。具体值依赖不同语言的初始化操作。</li>
</ul>


<p>重复型字段默认值为空。</p>

<p>注意，对于标量类型字段，一个消息解析时不会标示某个字段是否是显示设置为默认值，比如一个布尔型字段值为<code>false</code>时，不会告诉消息使用者这个布尔字段值为<code>false</code>还是被设置的默认值<code>false</code>。定义消息类型时，要注意这点。如果一个布尔字段值为<code>false</code>时，程序表现为某种行为，如果你不希望默认情况下程序表现为这种行为的话，就需要注意。对于标量类型字段，如果设置为默认值，那么将不会对这个字段进行编码传输。 <br/>
<a href="https://developers.google.com/protocol-buffers/docs/reference/overview">generated code guide</a>查看关于不同语言默认值如何工作的详细情况。</p>

<h2><a name="enum"></a>枚举</h2>

<p>定义消息类型时，可能需要设置字段值为一些预定义值，我们可以在消息定义文件中定义<code>enum</code>枚举类型，在<code>SearchRequest</code>中定义一个枚举类型<code>Corpus</code>：</p>

<pre><code>message SearchRequest {
    string query = 1;
    int32 page_number = 2;
    int32 result_per_page = 3;
    enum Corpus {
        UNIVERSAL = 0;
        WEB = 1;
        IMAGES = 2;
        LOCAL = 3;
        NEWS = 4;
        PRODUCTS = 5;
        VIDEO = 6;
    }
    Corpus corpus = 4;
}
</code></pre>

<p><code>Corpus</code>枚举类型的第一个常量值为0：protobuf中每一个枚举类型<code>必须</code>将第一个值定义为0，原因如下：</p>

<ul>
<li>必须有一个0值，这样可以使用0值为枚举类型默认值</li>
<li>0值必须为第一个值，这样是为了与<code>proto2</code>语法相兼容，<code>proto2</code>中以第一个枚举值为默认值</li>
</ul>


<p>可以为枚举值定义一个别名，需要在定义别名的枚举类型中设置<code>allow_alias</code>选项为<code>true</code>，否则编译器将会报错。</p>

<pre><code>enum EnumAllowingAlias {
    option allow_alias = true;
    UNKNOWN = 0;
    STARTED = 1;
    RUNNING = 1;
}   
enum EnumNotAllowingAlias {
    UNKNOWN = 0;
    STARTED = 1;
    // RUNNING = 1;  // Uncommenting this line will cause a         compile error inside Google and a warning message outside.
}
</code></pre>

<p>枚举类型常量值必须在32位整型之间。因为<code>enum</code>类型使用<a href="https://developers.google.com/protocol-buffers/docs/encoding">varint encoding</a>进行编码，值为负数的话，编码效率低，所以不推荐为负数。可以在消息定义体之中，或者之外定义<code>enum</code>枚举类型，可以在<code>.proto</code>文件任何为值使用这些枚举类型。 你可以通过<code>MessageType.EnumType</code>的方式使用在其他消息中定义的枚举类型。</p>

<p>当编译带有<code>enum</code>的<code>.proto</code>文件时，目标语言是<code>C++</code>或者<code>Java</code>时，产生的代码中包含<code>enum</code>定义，目标代码是<code>Python</code>时，产生一个<code>EnumDescriptor</code>类。</p>

<h2><a name="other_message"></a>使用其他消息类型</h2>

<p>可以使用其他消息类型定义字段。比如在<code>SearchResponse</code>消息中包含<code>Result</code>消息，<code>Result</code>消息可以定义在同一个<code>.proto</code>文件中。</p>

<pre><code>message SearchResponse {
    repeated Result results = 1;
}

message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
}
</code></pre>

<h3>引入定义</h3>

<p>上面的例子中，<code>Result</code>定义在<code>SearchResponse</code>同样的<code>.proto</code>文件中，如果需要使用的消息类型定义在其他文件中消息类型。</p>

<p>通过import<code>.proto</code>文件使用<code>.proto</code>文件中的定义。在自己<code>.proto</code>文件顶部添加一行引入语句：</p>

<pre><code>import "myproject/other_protos.proto";
</code></pre>

<p>默认情况下，只能使用被直接<code>import</code>的文件中的消息定义。如果需要将<code>.proto</code>文件挪到一个新的位置去，可以放一个替代<code>.proto</code>文件到老的位置，在这个替代文件中使用<code>import public</code>将定义转移到新位置。例子：</p>

<pre><code>// new.proto
// All definitions are moved here


// old.proto
// This is the proto that all clients are importing.
import public "new.proto";
import "other.proto";

// client.proto
import "old.proto";
// You use definitions from old.proto and new.proto, but not other.proto
</code></pre>

<p>编译器在<code>-I/--proto_path</code>参数指定的目录中搜索被引入的<code>.proto</code>文件。如果没有设置这个参数，编译器在当前目录下查找，通常情况下，应该设置<code>--proto_path</code>为工程的根目录。</p>

<h3>使用proto2消息类型</h3>

<p>可以在<code>proto3</code>消息中引入<code>proto2</code>消息类型。但是proto2枚举类型不能在proto3语法中直接使用。</p>

<h2><a name="nested"></a>嵌套类型</h2>

<p>可以在消息类型中定义其他类型，下面的例子中，<code>Result</code>消息定义在<code>SearchResponse</code>消息中：</p>

<pre><code>message SearchResponse {
    message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
    }
    repeated Result results = 1;
}  
</code></pre>

<p>如果想在<code>SearchResponse</code>消息以外使用<code>Result</code>消息，以<code>Parent.Type</code>格式使用：</p>

<pre><code>message SomeOtherMessage {
    SearchResponse.Result result = 1;
}
</code></pre>

<p>可以任意潜逃消息定义：</p>

<pre><code>message Outer {                  // Level 0
    message MiddleAA {  // Level 1
        message Inner {   // Level 2
            int64 ival = 1;
            bool  booly = 2;
        }
    }
    message MiddleBB {  // Level 1
        message Inner {   // Level 2
            int32 ival = 1;
            bool  booly = 2;
        }
    }
}
</code></pre>

<h2><a name="update"></a>更新消息类型</h2>

<p>如果已有消息不能满足新的需求，比如，需要增加一个新的字段，但是仍然使用根据老的消息格式产生的代码，对于protocol buffer来说这很容易完成，请记住如下的规则：</p>

<ul>
<li>不要修改当前字段的标签值</li>
<li>如果新增字段，任何根据老格式序列化的消息，都能够被根据新格式产生的代码进行解析。这种情况下，新增字段的值都会被设置为<a href="https://developers.google.com/protocol-buffers/docs/proto3#default">默认值</a>。新格式消息同样可以为老格式代码解析，新增字段将会被忽略。</li>
<li>可以删除字段，只要新消息格式中该字段标签值没有被使用。对于删除的字段，最好是对字段名称进行修改，添加<code>OBSOLETE_</code>字段或者设置tag为<a href="https://developers.google.com/protocol-buffers/docs/proto3#reserved">reserved</a>，这样未来不会错误使用该tag值。</li>
<li><code>int32</code>,<code>uint32</code>,<code>int64</code>,<code>uint64</code>,<code>bool</code>都是兼容的，意味着可以将字段从一种类型修改为另一种。如果解析时，从序列化数据中解析出的数据与响应字段类型不匹配，那么行为表现为从类型转换。</li>
<li><code>sint32</code>和<code>sint64</code>互相兼容，但是与其他整型类型不兼容。</li>
<li><code>string</code>和<code>bytes</code>互相兼容，只要bytes是UTF-8格式。</li>
<li>嵌套消息与<code>bytes</code>互相兼容，只要bytes包含该消息的编码</li>
<li><code>fixed32</code>与<code>sfixed32</code>，<code>fixed64</code>，<code>sfixed64</code>相兼容。</li>
<li><code>enum</code>与<code>int32</code>，<code>uint32</code>，<code>int64</code>，<code>uint64</code>相兼容</li>
</ul>


<h2><a name="unknown"></a>未知字段</h2>

<p>未知字段是正确格式数据，解析程序不能识别的字段。当旧格式解析程序解析新格式消息时，解析程序无法识别新格式消息中新增字段，认为为未知字段。</p>

<p><code>Proto3</code>实现可以解析这些未知字段，但是实现可能不支持保留这些字段。不应依赖这些未知字段。对于大部分实现，未知字段都是不可访问的，在序列化时，未知字段将会被忽略。这与<code>proto2</code>不同，未知字段也会被保留和序列化。</p>

<h2><a name="any"></a>Any</h2>

<p><code>Any</code>消息类型允许你使用某消息类型，而不需要引入该类型消息<code>.proto</code>文件。<code>Any</code>类型包含任意<code>bytes</code>类型序列化数据，<code>Any</code>类型包含一个URL，作为消息类型的唯一标识。引入<code>google/protobuf/any.proto</code>来使用<code>Any</code>类型。</p>

<pre><code>import "google/protobuf/any.proto";

message ErrorStatus {
    string message = 1;
    repeated google.protobuf.Any details = 2;
}
</code></pre>

<p>一个消息类型的默认URL为<code>type.googleapis.com/packagename.messagename</code>。</p>

<p>不同语言都会有运行时库去打包和解包Any类型值，Java中，Any类型字段会有<code>pack()</code>和<code>unpack()</code>方法访问，C++语言中有<code>PackFrom()</code>和<code>UnpackTo()</code>方法：</p>

<pre><code>// Storing an arbitrary message type in Any.
NetworkErrorDetails details = ...;
ErrorStatus status;
status.add_details()-&gt;PackFrom(details);

// Reading an arbitrary message from Any.
ErrorStatus status = ...;
for (const Any&amp; detail : status.details()) {
    if (detail.Is&lt;NetworkErrorDetails&gt;()) {
        NetworkErrorDetails network_error;
        detail.UnpackTo(&amp;network_error);
        ... processing network_error ...
    }
}
</code></pre>

<h2><a name="oneof"></a>Oneof</h2>

<p>如果消息中包含多个字段，同一时间最多设置一个字段，可以使用<code>oneof</code>特性来强制这种行为并且节省内存。</p>

<p>设置<code>oneof</code>中的任一字段将会清楚其他字段值。可以使用<code>case</code>或者<code>WhichOneof</code>方法查看当前哪个字段被设置。</p>

<h3>使用Oneof</h3>

<p>使用<code>oneof</code>关键词在<code>.proto</code>文件中定义：</p>

<pre><code>message SampleMessage {
    oneof test_oneof {
        string name = 4;
        SubMessage sub_message = 9;
    }
}
</code></pre>

<p>可以在oneof定义中添加除了<code>repeated</code>以外任意类型的字段。</p>

<p>产生的代码中，对于oneof中的字段拥有跟普通字段一样的获取、设置函数。还会获取一个特殊方法检查哪个值被设置。关于oneof更多API请参考<a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference</a>。</p>

<h3>Oneof 特性</h3>

<ul>
<li><p>设置oneof字段会清楚其他字段值。如果多次设置oneof字段值，只保留最后一次设置值。</p>

<pre><code>  SampleMessage message;
  message.set_name("name");
  CHECK(message.has_name());
  message.mutable_sub_message();   // Will clear name field.
  CHECK(!message.has_name());  
</code></pre></li>
<li>如果解析程序遇到oneof定义中的多个字段值，只有最后一个是有效的。</li>
<li>不能将一个<code>oneof</code>类型用于<code>repeated</code>中</li>
<li>反射对于oneof字段有效</li>
<li><p>使用C++时，防止非法访问内存。下面代码示例中，执行<code>set_name</code>时，<code>sub_message</code>已经被清除：</p>

<pre><code>  SampleMessage message;
  SubMessage* sub_message = message.mutable_sub_message();
  message.set_name("name");      // Will delete sub_message
  sub_message-&gt;set_...            // Crashes here
</code></pre>

<p>*使用C++ oneof <code>Swap</code>方法时，互换两个变量中设置的字段值：</p>

<pre><code>  SampleMessage msg1;
  msg1.set_name("name");  
  SampleMessage msg2;
  msg2.mutable_sub_message();
  msg1.swap(&amp;msg2);
  CHECK(msg1.has_sub_message());
  CHECK(msg2.has_name());
</code></pre></li>
</ul>


<h3>向后兼容问题</h3>

<p>添加或者删除oneof字段时要小心。如果检查oneof值时返回<code>None</code>或者<code>NOT_SET</code>时,意味着oneof没有被设置或者设置了oneof的一个其他版本。 因为没有办法区分一个未知字段是新加字段。</p>

<p>复用标签问题</p>

<ul>
<li>添加或者移除字段： 可能会丢失某些字段信息。</li>
<li>删除字段后又添加：</li>
<li>分拆或者合并：</li>
</ul>


<h2><a name="maps"></a>Maps</h2>

<p>protocol buffers提供一个映射类型定义字段：</p>

<pre><code>map&lt;key_type, value_type&gt; map_field = N;
</code></pre>

<p><code>key_type</code>可以为整型或者字符串类型（除了<code>floating point</code>和<code>bytes</code>以外的标量类型）。<code>value_type</code>可以为任何类型。</p>

<p>下面定义个map类型字段，每个<code>project</code>对应一个字符串：</p>

<pre><code>map&lt;string, Project&gt; projects = 3;
</code></pre>

<ul>
<li>Map字段不可以是<code>repeated</code></li>
<li>不依赖map顺序</li>
<li>生成<code>.proteo</code>文本格式时，maps以key排序。数字按照数字排序</li>
</ul>


<h3>向后兼容</h3>

<p>map语法等同于下面的消息定义，所以不支持map的protocol buffers实现仍然可以解析数据：</p>

<pre><code>message MapFieldEntry {
    key_type key = 1;
    value_type value = 2;
}

repeated MapFieldEntry map_field = N;
</code></pre>

<h2><a name="packages"></a>包</h2>

<p>可以在<code>.proto</code>文件中添加一个<code>package</code>可选项，防止消息类型命名冲突。</p>

<pre><code>package foo.bar;
message Open { ... }
</code></pre>

<p>可以在定义字段时使用包名：</p>

<pre><code>message Foo {
    ...
    foo.bar.Open open = 1;
    ...
}
</code></pre>

<p>根据不同语言产生不同的代码：</p>

<ul>
<li>C++中，产生的类包含在C++命名空间中，例如，<code>Open</code>将会出现在<code>foo::bar</code>命名空间</li>
<li>Java，<code>package</code>名被用来作为Java包名，除非在<code>.proto</code>文件中使用<code>option java_package</code>指定包名</li>
<li>Python，<code>package</code>指令被忽略，因为Python中包是按照在文件系统中的路径组织的</li>
<li>Go，<code>package</code>包名被用做Go代码包名，除非使用<code>option java_package</code>指定包名</li>
<li>Ruby，产生的代码包裹在Ruby命名空间，命名空间名称根据<code>package</code>参数包名生成</li>
<li>JavaNano，<code>package</code>参数名被用做产生代码包名</li>
<li>C#，<code>package</code>参数名被用来作为产生代码包名</li>
</ul>


<h3>包和命名查找</h3>

<p>protocol buffer中名字查找规则与C++类似：从内到外，逐层查找。<code>.foo.bar.Baz</code>意思是从最外层开始查找。</p>

<h2><a name="services"></a>定义服务</h2>

<p>如果在<code>RPC</code>中使用定义的消息类型，可以在<code>.proto</code>文件中定义一个RPC服务接口，protocol buffer编译器将会产生服务接口代码。下面定义一个服务函数，输入<code>SearchRequest</code>返回一个<code>SearchResponse</code>：</p>

<pre><code>service SearchService {
    rpc Search (SearchRequest) returns (SearchResponse);
}
</code></pre>

<p>最简单的使用protocol buffers的RPC系统是<a href="https://github.com/grpc/grpc-common">gRPC</a>：Google开发的一个语言和平台无关的开源RPC系统。使用一个protocol buffer编译器插件可以直接从<code>.proto</code>文件中直接生成相应的RPC代码。</p>

<h2><a name="json"></a>JSON映射</h2>

<p>Proto3支持JSON编码，方便系统间共享数据。下面的表格列入了Proto3消息类型与JSON对应关系。</p>

<p><img src="http://jintao-zero.github.io/images/proto-6.png" alt="" />
<img src="http://jintao-zero.github.io/images/proto-7.png" alt="" /></p>

<h2><a name="options"></a>Options选项</h2>

<p>单独的声明可以用一些options修饰。选项不会改变一个声明的总体意义，但是会影响在特殊上下文中的意义。完整options选项定义在<code>google/protobuf/descriptor.proto</code>。<br/>
一些options选项是文件级别的。一些选项是消息级别的。一些选项是字段级别的。<br/>
下面是一些经常是用的选项：</p>

<ul>
<li><p><code>java_package</code>(文件级别选项)：使用这个选项指定产生的java代码包名。如果没有使用这个参数显示指定包名，编译器将会使用<code>.proto</code>文件中package指定的包名作为java代码包名。但是proto包名生成的java包名并不符合Java包名倒序的惯例。如果不是生成Java代码，这个选项无效：</p>

<pre><code>  option java_package = "com.example.foo";
</code></pre></li>
<li><p><code>java_multiple_files</code>（文件级别选项）：指定产生的最外层Java类名。如果没有使用<code>java_outer_classname</code>参数，则使用<code>.proto</code>文件名作为最外层类名，文件名被转换成驼峰模式（<code>foo_bar.proto</code>生成<code>FooBar.java</code>）。如果不是生成java代码，下面选项无效：</p>

<pre><code>  option java_outer_classname = "Ponycopter";
</code></pre></li>
<li><p><code>optimize_for</code>（文件级别选项）：可以设置为<code>SPEED</code>，<code>CODE_SIZE</code>，<code>LITE_RUNTIME</code>。这个参数按照下面方式影响C++和Java代码生成：</p>

<ul>
<li><code>SPEED</code>(默认值)：protocol buffer编译器为消息类型生成序列化、反序列化和其他操作的相关代码。代码是高度优化的。</li>
<li><code>CODE_SIZE</code>：protocol buffer编译器生成最少类，依赖共享的，基于反射的代码去实现序列化、反序列化和其他操作。生成的代码与<code>SPEED</code>相比很小，但是更慢。生成的类的接口与<code>SPEED</code>模式一样。这个选项在拥有大量<code>.proto</code>文件不需要它们都很快。</li>
<li><p><code>LITE_RUNTIME</code>：编译器将生成类只依赖轻运行时库（<code>libprotobuf-lite</code>而不是<code>libprotobuf</code>）。轻运行时库比全库更小。这对于运行在限制平台（比如智能手机）的应用很有用。编译器将会生成跟<code>SPEED</code>选项一样的高效代码。生成的类只实现<code>MessageLite</code>接口，只提供了全<code>Message</code>接口方法的子集。</p>

<pre><code>  option optimize_for = CODE_SIZE;
</code></pre></li>
</ul>
</li>
<li><p><code>cc_enable_arenas</code>（文件级别选项）：为产生的C++代码使能<a href="https://developers.google.com/protocol-buffers/docs/reference/arenas">arena allocation</a></p></li>
<li><code>objc_class_prefix</code>（文件级别选项）：为产生的Objective-C代码添加前缀。没有默认值，应该按照Apple推荐的惯例设置此选项。</li>
<li><p><code>deprecated</code>（文件级别选项）：如果设置为<code>true</code>，指示这个字段已弃用。在大多数语言中，这个选项无效。Java代码中，这个选项变成<code>@Deprecated</code>注解。</p>

<pre><code>  int32 old_field = 6 [deprecated=true];
</code></pre>

<h2>自定义选项</h2>

Protocol Buffers also allows you to define and use your own options. This is an advanced feature which most people don&rsquo;t need. If you do think you need to create your own options, see the Proto2 Language Guide for details. Note that creating custom options uses extensions, which are permitted only for custom options in proto3.

<h2><a name="protoc"></a>生成代码</h2>

<p>使用<code>protoc</code>编译器根据<code>.proto</code>文件生成Java，Python，C++，Go，Ruby，JavaNano，Objective-C，或者C#代码。如果格式调用程序：</p>

<pre><code>  protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto
</code></pre></li>
<li><p><code>IMPORT_PATH</code> 指定目录，在目录中查找<code>import</code>指令引入的文件。如果没有制定，使用当前目录。可以多次使用<code>--proto_path</code>参数指定多个路径；按照顺序查找。<code>-I=IMPORT_PATH</code>可以作为<code>--proto_path</code>的短形式</p></li>
<li>可以设置多个输出指令：

<ul>
<li><code>--cpp_out</code>在<code>DST_DIR</code>中生成C++代码。</li>
<li><code>--java_out</code>在<code>DST_DIR</code>中生成Java代码</li>
<li><code>--python_out</code>在<code>DST_DIR</code>中生成Python代码</li>
<li><code>--go_out</code>在<code>DST_DIR</code>中生成Go代码</li>
<li><code>--ruby_out</code>在<code>DST_DIR</code>中生成Ruby代码</li>
<li><code>--javanano_out</code>在<code>DST_DIR</code>中生成JavaNano代码</li>
<li><code>--objc_out</code>在<code>DST_DIR</code>中生成Objective-C代码</li>
<li><code>--csharp_out</code>在<code>DST_DIR</code>中生成C#代码</li>
<li><code>--php_out</code>在<code>DST_DIR</code>中生成PHP代码</li>
</ul>
</li>
<li>必须指定一个或者多个<code>.proto</code>文件作为参数。多个<code>.proto</code>文件可以同时指定。每个文件必须在<code>IMPORT_PATH</code>指定的路径中能够查找到</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Defer Panic 和Recover介绍和实践]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/03/07/golang-defer-panic-he-recoverjie-shao/"/>
    <updated>2017-03-07T11:08:41+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/03/07/golang-defer-panic-he-recoverjie-shao</id>
    <content type="html"><![CDATA[<p>Golang语言提供了正常的流程控制：if、for、switch和goto。还提供了go表达式创建goroutine协程。接下来将要介绍的是：<code>defer</code>、<code>panic</code>和<code>recovery</code></p>

<h2>defer</h2>

<p>defer表达式将一个函数放到一个list中。包裹defer函数的函数return时，这个defer函数将会被执行。<code>Defer</code>通常被用来简化资源清理动作。  <br/>
下面的代码片段，完成的功能是打开两个文件，将一个文件的内容拷贝到另外一个文件中：</p>

<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }

    written, err = io.Copy(dst, src)
    dst.Close()
    src.Close()
    return
}
</code></pre>

<p>这个片段有bug。当调用os.Createa失败时，函数返回，但是没有将已经打开的源文件关闭。在第二个return语句之前执行src.Close可以修复bug。但是如果存在多个资源需要关闭或者多个return语句时，这样就比较繁琐。使用defer表达式，可以方便确保资源关闭：</p>

<pre><code>func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }
    defer src.Close()

    dst, err := os.Create(dstName)
    if err != nil {
        return
    }
    defer dst.Close()

    return io.Copy(dst, src)
}
</code></pre>

<p>Defer表达式会提醒我们在打开文件之后关闭资源，并且确保无论多少return语句都会将资源关闭。<br/>
defer表达式的行为是简单和可预测的。下面有三条简单规则：</p>

<ol>
<li><p>注册defer函数时，计算deferred函数的参数
下面的例子中，defer表达式注册fmt.Println函数时确定了入参为0，下面函数执行return语句时，fmt.Println将会打印出0</p>

<pre><code>  func a() {
      i := 0
      defer fmt.Println(i)
      i++
      return
  }
</code></pre></li>
<li><p>注册函数按照先进后出的的顺序进行执行</p>

<pre><code> func b() {
     for i := 0; i &lt; 4; i++ {
         defer fmt.Print(i)
      }
 }
</code></pre>

<p> 打印结果是“3210”</p></li>
<li><p>Deferred函数可以读写包裹函数的命名返回值
下面的例子中，包裹函数返回后，deferred函数修改了命名返回值i。因此，包裹函数的返回值为2</p>

<pre><code>  func c() (i int) {
      defer func() { i++ }()
      return 1
  }
</code></pre>

<p>  这个特点可以用来修改函数返回的error返回值</p></li>
</ol>


<!-- more -->


<h2>Panic</h2>

<p><code>panic</code>是Golang内建函数，它会停止当前流程，开始<code>panicking</code>。当函数F调用panic时，F将会停止执行正常流程，执行F函数中注册的defer函数，然后F函数返回。对于F函数的调用函数，F函数表现为panic。F函数的调用函数按照F函数panic时的行为一样，执行deferred函数后返回，这样沿着沿着调用栈，直到最上层，之后程序崩溃。<code>Panic</code>可以由程序调用<code>panic</code>函数后触发，也会有运行时错误触发，比如slice越界访问。</p>

<h2>Recover</h2>

<p><code>recover</code>内建函数，可以用来从处于<code>panic</code>状态的goroutine中重新获取控制。<code>recover</code>只有在defer函数中才有用。在正常状态下，调用recover函数返回nil，不会有其他作用。如果当前goroutine处于<code>panicking</code>状态，那么调用<code>recover</code>函数，可以获取<code>panic</code>函数的参数，并终止<code>panicking</code>状态，进入正常状态。
下面的例子演示如何利用<code>defer</code>、<code>panic</code>和<code>recover</code>：</p>

<pre><code>package main

import "fmt"

func main() {
    f()
    fmt.Println("Returned normally from f.")
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()
    fmt.Println("Calling g.")
    g(0)
    fmt.Println("Returned normally from g.")
}

func g(i int) {
    if i &gt; 3 {
    fmt.Println("Panicking!")
        panic(fmt.Sprintf("%v", i))
    }
    defer fmt.Println("Defer in g", i)
    fmt.Println("Printing in g", i)
    g(i + 1)
}
</code></pre>

<p>程序输出如下：</p>

<pre><code>Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
Recovered in f 4
Returned normally from f.
</code></pre>

<p>如果我们删除F函数中的defer函数，那么panic将不会得到恢复，一直到到goroutine调用栈的最顶层，终止程序执行。这样程序的输出如下：</p>

<pre><code>Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
panic: 4

panic PC=0x2a9cd8
[stack trace omitted]
</code></pre>

<h2>实践</h2>

<p>使用<code>defer</code>和<code>recover</code>构造一个带recover的goroutine包裹函数</p>

<pre><code>func defaultPanicHandler(e interface{}) {
    fmt.Println(e)
    debug.PrintStack()
    // log here
}

var PanicHandler func(interface{}) = defaultPanicHandler

func withRecover(fn func()) {
    defer func() {
        handler := PanicHandler
        if handler != nil {
            if err := recover(); err != nil {
                handler(err)
            }
        }
    }()
    fn()
}

func main () {
    go withRecover(
        func () {
            fmt.Println("aaaa")
            panic("panicking")
        }
    )
    for {
        time.Sleep(3 * time.Second)
    }
}
</code></pre>

<p>参考：</p>

<ol>
<li><a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Reflect介绍]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/03/06/golang-reflectjie-shao/"/>
    <updated>2017-03-06T17:44:02+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/03/06/golang-reflectjie-shao</id>
    <content type="html"><![CDATA[<p>Golang <a href="https://golang.org/pkg/reflect/">reflect</a>包实现了运行时反射，允许程序管理任意类型对象。典型应用是使用<code>TypeOf</code>从静态类型<code>interface{}</code>中抽取动态类型信息。<br/>
使用<code>ValueOf</code>返回一个<code>Value</code>类型变量代表运行时数据。<br/>
<a href="https://golang.org/doc/articles/laws_of_reflection.html">The Laws of Reflection</a>介绍了Golang reflect机智中的几条规则：</p>

<h2>从interface反射到对象</h2>

<p>反射基本功能是用来检查interface变量中保存的<code>类型</code>和<code>数据</code>对。<a href="http://golang.org/pkg/reflect/">package reflect</a>中提供了两种类型：<a href="http://golang.org/pkg/reflect/#Type">Type</a>和<a href="http://golang.org/pkg/reflect/#Value">Value</a>。这两种类型提供了反问interface内部数据的机制。调用<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>函数分别返回<code>reflect.Type</code>和<code>reflect.Value</code>变量：</p>

<pre><code>ackage main

import (
"fmt"
"reflect"
)

func main() {
    var x float64 = 3.4
    fmt.Println("type:", reflect.TypeOf(x))
}
</code></pre>

<p>程序输出如下：</p>

<pre><code>type: float64
</code></pre>

<p><code>reflect.TypeOf</code>函数定义如下：</p>

<pre><code>// TypeOf returns the reflection Type of the value in the interface{}.
func TypeOf(i interface{}) Type
</code></pre>

<p>当我们调用<code>TypeOf(x)</code>时，x首先存在一个空interface中，之后作为参数，reflect.TypeOf解析参数获取实际类型。  <br/>
调用<code>Value(x)</code>时，从接口参数中获取实参值。</p>

<pre><code>var x float64 = 3.4
fmt.Println("value:", reflect.ValueOf(x))
</code></pre>

<p>打印结果如下：</p>

<pre><code>value: &lt;float64 Value&gt;
</code></pre>

<!-- more -->


<p></p>

<h2>从反射对象逆转回接口值</h2>

<p>给定一个<code>reflect.Value</code>对象，调用<code>Interface</code>方法可以恢复一个接口值。实际上，<code>Interface</code>方法将Value对象的值和类型信息打包到一个接口值中并返回：</p>

<pre><code>// Interface returns v's value as an interface{}.
func (v Value) Interface() interface{}
</code></pre>

<p>接上面的例子：</p>

<pre><code>y := v.Interface().(float64) // y will have type float64.
fmt.Println(y)
</code></pre>

<p>将反射对象v代表的float64值打印。</p>

<h2>如果修改一个反射对象，value必须可设置</h2>

<p><code>reflect.ValueOf</code>返回的Value值，并不是所有情况下都是可修改的。下面示例：</p>

<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.
</code></pre>

<p>执行代码时，报如下panic错误：</p>

<pre><code>panic: reflect.Value.SetFloat using unaddressable value
</code></pre>

<p>反射对象v不是可设置的。可设置是<code>reflect.Value</code>类型对象的一个属性，不是所有<code>Value</code>对象有此属性。<br/>
Value对象<code>CanSet</code>方法返回Value对象是否可以设置，在我们的例子中：</p>

<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("settability of v:", v.CanSet())
</code></pre>

<p>将会输出：</p>

<pre><code>settability of v: false
</code></pre>

<p><code>Settability</code>是反射对象的一个属性，它反映的是是否能够修改创建这个反射对象的原对象。<code>Settability</code>由反射对象是否持有原对象决定。</p>

<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
</code></pre>

<p>当我们执行上面代码时，根据x生成一个interface对象作为是实参调用<code>reflect.Value</code>，interface对象保存的是x值拷贝。</p>

<pre><code>v.SetFloat(7.1)
</code></pre>

<p>上面代码修改的并不是x值。<br/>
对于函数调用，如果想修改实参，那必须传递实参地址到函数中。</p>

<pre><code>var x float64 = 3.4
p := reflect.ValueOf(&amp;x) // Note: take the address of x.
fmt.Println("type of p:", p.Type())
fmt.Println("settability of p:", p.CanSet())
</code></pre>

<p>上面代码，我们创建了一个x地址的反射对象，代码的输出如下：</p>

<pre><code>type of p: *float64
settability of p: false
</code></pre>

<p>反射对象p是不可设置的，我们不是要修改p，而是要修改p指向的x对象。  调用<code>Elem</code>方法可以获取p所指向的原对象：</p>

<pre><code>v := p.Elem()
fmt.Println("settability of v:", v.CanSet())
</code></pre>

<p>现在v对象就是可以修改的了：</p>

<pre><code>settability of v: true
</code></pre>

<p>现在v对象代表了原对象x，现在可以对v对象进行设置：</p>

<pre><code>v.SetFloat(7.1)
fmt.Println(v.Interface())
fmt.Println(x)
</code></pre>

<p>结果输出如下：<br/>
    7.1
    7.1</p>

<h3>Structs</h3>

<p>当我们拥有struct结构体对象地址时，可以对结构体对象进行修改<br/>
接下来是一个小的示例，使用结构体对象地址创建一个反射对象，然后使用reflect包中提供的结构体相关的方法，对结构体对象进行遍历和修改。</p>

<pre><code>type T struct {
    A int
    B string
}
t := T{23, "skidoo"}
s := reflect.ValueOf(&amp;t).Elem()
typeOfT := s.Type()
for i := 0; i &lt; s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf("%d: %s %s = %v\n", i,
    typeOfT.Field(i).Name, f.Type(), f.Interface())
}
</code></pre>

<p>上面代码的输出如下：</p>

<pre><code>0: A int = 23
1: B string = skidoo
</code></pre>

<p>因为s是可设置的反射对象，我们可以修改原对象的字段值：</p>

<pre><code>s.Field(0).SetInt(77)
s.Field(1).SetString("Sunset Strip")
fmt.Println("t is now", t)
</code></pre>

<p>结果如下：</p>

<pre><code>t is now {77 Sunset Strip}
</code></pre>

<h2>案例</h2>

<p>参考：</p>

<p>1、<a href="https://golang.org/pkg/reflect/">https://golang.org/pkg/reflect/</a>   <br/>
2、<a href="https://blog.golang.org/laws-of-reflection">https://blog.golang.org/laws-of-reflection</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang使用protobuf搭建rpc]]></title>
    <link href="http://jintao-zero.github.io/blog/2017/02/03/golangshi-yong-protobufda-jian-rpc/"/>
    <updated>2017-02-03T19:55:10+08:00</updated>
    <id>http://jintao-zero.github.io/blog/2017/02/03/golangshi-yong-protobufda-jian-rpc</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
